<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>二十四節気タスク管理</title>
    
    <!-- PWA設定 -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1f2937">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="二十四節気">

    <!-- Favicon Links: Added for bookmarking and browser tabs -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%23fdfdfd'/%3E%3Cpath d='M 50 0 A 50 50 0 0 1 100 50 L 50 50 Z' fill='%23a7e0e8'/%3E%3Cpath d='M 100 50 A 50 50 0 0 1 50 100 L 50 50 Z' fill='%23e09a73'/%3E%3Cpath d='M 50 100 A 50 50 0 0 1 0 50 L 50 50 Z' fill='%23ddebf0'/%3E%3Cpath d='M 0 50 A 50 50 0 0 1 50 0 L 50 50 Z' fill='%23ffd9e1'/%3E%3Ccircle cx='50' cy='50' r='22' fill='%23fdfdfd'/%3E%3Ctext x='50' y='62' font-family='Shippori Mincho, serif' font-size='38' fill='%234a4a4a' text-anchor='middle'%3E暦%3C/text%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%23fdfdfd'/%3E%3Cpath d='M 50 0 A 50 50 0 0 1 100 50 L 50 50 Z' fill='%23a7e0e8'/%3E%3Cpath d='M 100 50 A 50 50 0 0 1 50 100 L 50 50 Z' fill='%23e09a73'/%3E%3Cpath d='M 50 100 A 50 50 0 0 1 0 50 L 50 50 Z' fill='%23ddebf0'/%3E%3Cpath d='M 0 50 A 50 50 0 0 1 50 0 L 50 50 Z' fill='%23ffd9e1'/%3E%3Ccircle cx='50' cy='50' r='22' fill='%23fdfdfd'/%3E%3Ctext x='50' y='62' font-family='Shippori Mincho, serif' font-size='38' fill='%234a4a4a' text-anchor='middle'%3E暦%3C/text%3E%3C/svg%3E">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;700&family=Zen+Old+Mincho&display=swap');
        
        body {
            font-family: 'Shippori Mincho', serif;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .sekki-title {
            font-family: 'Zen Old Mincho', serif;
        }
        
        /* 24節気ごとの背景 */
        /* 春 - Spring */
        .bg-立春 { /* 立春 - Beginning of Spring */
            background: 
                radial-gradient(circle at 30% 70%, rgba(255, 182, 193, 0.3) 0%, transparent 40%),
                radial-gradient(circle at 70% 30%, rgba(255, 218, 185, 0.25) 0%, transparent 45%),
                linear-gradient(135deg, #fff0f5 0%, #ffe4e1 100%);
        }
        .bg-雨水 { /* 雨水 - Rain Water */
            background:
                radial-gradient(ellipse at 20% 80%, rgba(173, 216, 230, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(135, 206, 250, 0.25) 0%, transparent 40%),
                linear-gradient(180deg, #e6f3ff 0%, #f0f8ff 100%);
        }
        .bg-啓蟄 { /* 啓蟄 - Awakening of Insects */
            background:
                radial-gradient(circle at 25% 75%, rgba(144, 238, 144, 0.3) 0%, transparent 40%),
                radial-gradient(circle at 75% 25%, rgba(152, 251, 152, 0.25) 0%, transparent 45%),
                linear-gradient(135deg, #f0fff0 0%, #e8f5e8 100%);
        }
        .bg-春分 { /* 春分 - Spring Equinox */
            background:
                radial-gradient(circle at 50% 50%, rgba(255, 192, 203, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 20% 80%, rgba(255, 182, 193, 0.25) 0%, transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(255, 218, 185, 0.25) 0%, transparent 40%),
                linear-gradient(135deg, #fff5ee 0%, #ffe4e1 100%);
        }
        .bg-清明 { /* 清明 - Clear and Bright */
            background:
                radial-gradient(circle at 30% 60%, rgba(255, 228, 225, 0.4) 0%, transparent 50%),
                radial-gradient(circle at 70% 40%, rgba(255, 192, 203, 0.3) 0%, transparent 45%),
                linear-gradient(120deg, #fff5f5 0%, #ffe0e6 100%);
        }
        .bg-穀雨 { /* 穀雨 - Grain Rain */
            background:
                radial-gradient(ellipse at 40% 60%, rgba(135, 206, 235, 0.3) 0%, transparent 45%),
                radial-gradient(ellipse at 60% 40%, rgba(176, 224, 230, 0.3) 0%, transparent 50%),
                linear-gradient(180deg, #e6f7ff 0%, #f0ffff 100%);
        }
        
        /* 夏 - Summer */
        .bg-立夏 { /* 立夏 - Beginning of Summer */
            background:
                radial-gradient(circle at 30% 70%, rgba(144, 238, 144, 0.35) 0%, transparent 45%),
                radial-gradient(circle at 70% 30%, rgba(124, 252, 0, 0.25) 0%, transparent 40%),
                linear-gradient(135deg, #f0fff4 0%, #e6ffe6 100%);
        }
        .bg-小満 { /* 小満 - Grain Buds */
            background:
                radial-gradient(circle at 25% 75%, rgba(255, 215, 0, 0.25) 0%, transparent 40%),
                radial-gradient(circle at 75% 25%, rgba(255, 255, 224, 0.3) 0%, transparent 45%),
                linear-gradient(120deg, #fffef0 0%, #fff8dc 100%);
        }
        .bg-芒種 { /* 芒種 - Grain in Ear */
            background:
                radial-gradient(ellipse at 50% 80%, rgba(189, 183, 107, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 20%, rgba(238, 232, 170, 0.25) 0%, transparent 45%),
                linear-gradient(180deg, #f5f5dc 0%, #fafad2 100%);
        }
        .bg-夏至 { /* 夏至 - Summer Solstice */
            background:
                radial-gradient(ellipse at 50% 10%, rgba(255, 223, 0, 0.4) 0%, transparent 35%),
                radial-gradient(circle at 30% 90%, rgba(135, 206, 250, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 70% 90%, rgba(0, 191, 255, 0.25) 0%, transparent 45%),
                linear-gradient(to bottom, #fff8dc 0%, #e0f7fa 100%);
        }
        .bg-小暑 { /* 小暑 - Minor Heat */
            background:
                radial-gradient(circle at 20% 80%, rgba(255, 160, 122, 0.3) 0%, transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(255, 218, 185, 0.3) 0%, transparent 45%),
                linear-gradient(135deg, #fff5ee 0%, #ffe4b5 100%);
        }
        .bg-大暑 { /* 大暑 - Major Heat */
            background:
                radial-gradient(ellipse at 50% 0%, rgba(255, 140, 0, 0.35) 0%, transparent 40%),
                radial-gradient(circle at 25% 100%, rgba(255, 69, 0, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 75% 100%, rgba(255, 99, 71, 0.2) 0%, transparent 50%),
                linear-gradient(180deg, #fff4e6 0%, #ffe0cc 100%);
        }
        
        /* 秋 - Autumn */
        .bg-立秋 { /* 立秋 - Beginning of Autumn */
            background:
                radial-gradient(circle at 30% 70%, rgba(255, 222, 173, 0.35) 0%, transparent 45%),
                radial-gradient(circle at 70% 30%, rgba(255, 228, 181, 0.3) 0%, transparent 40%),
                linear-gradient(135deg, #fffaf0 0%, #ffefd5 100%);
        }
        .bg-処暑 { /* 処暑 - End of Heat */
            background:
                radial-gradient(ellipse at 40% 60%, rgba(176, 196, 222, 0.3) 0%, transparent 45%),
                radial-gradient(ellipse at 60% 40%, rgba(176, 224, 230, 0.25) 0%, transparent 40%),
                linear-gradient(120deg, #f0f8ff 0%, #e6e6fa 100%);
        }
        .bg-白露 { /* 白露 - White Dew */
            background:
                radial-gradient(circle at 25% 75%, rgba(245, 245, 245, 0.5) 0%, transparent 35%),
                radial-gradient(circle at 75% 25%, rgba(220, 220, 220, 0.3) 0%, transparent 40%),
                linear-gradient(135deg, #f8f8ff 0%, #f0f0f0 100%);
        }
        .bg-秋分 { /* 秋分 - Autumn Equinox */
            background:
                radial-gradient(circle at 20% 80%, rgba(255, 140, 0, 0.25) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(255, 215, 0, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(218, 165, 32, 0.25) 0%, transparent 40%),
                linear-gradient(135deg, #fffaf0 0%, #fff8dc 100%);
        }
        .bg-寒露 { /* 寒露 - Cold Dew */
            background:
                radial-gradient(ellipse at 30% 70%, rgba(221, 160, 221, 0.3) 0%, transparent 45%),
                radial-gradient(ellipse at 70% 30%, rgba(186, 85, 211, 0.2) 0%, transparent 40%),
                linear-gradient(120deg, #f8f0ff 0%, #f0e6ff 100%);
        }
        .bg-霜降 { /* 霜降 - Frost Descent */
            background:
                radial-gradient(circle at 40% 60%, rgba(230, 230, 250, 0.4) 0%, transparent 50%),
                radial-gradient(circle at 60% 40%, rgba(216, 191, 216, 0.3) 0%, transparent 45%),
                linear-gradient(180deg, #f0f0ff 0%, #e6e6fa 100%);
        }
        
        /* 冬 - Winter */
        .bg-立冬 { /* 立冬 - Beginning of Winter */
            background:
                radial-gradient(circle at 30% 70%, rgba(176, 196, 222, 0.35) 0%, transparent 45%),
                radial-gradient(circle at 70% 30%, rgba(173, 216, 230, 0.3) 0%, transparent 40%),
                linear-gradient(135deg, #f0f8ff 0%, #e0efff 100%);
        }
        .bg-小雪 { /* 小雪 - Minor Snow */
            background:
                radial-gradient(circle at 25% 75%, rgba(248, 248, 255, 0.5) 0%, transparent 40%),
                radial-gradient(circle at 75% 25%, rgba(240, 248, 255, 0.4) 0%, transparent 45%),
                linear-gradient(120deg, #f8f8ff 0%, #f0f8ff 100%);
        }
        .bg-大雪 { /* 大雪 - Major Snow */
            background:
                radial-gradient(ellipse at 50% 50%, rgba(255, 255, 255, 0.6) 0%, transparent 50%),
                radial-gradient(circle at 20% 80%, rgba(240, 248, 255, 0.4) 0%, transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(248, 248, 255, 0.4) 0%, transparent 40%),
                linear-gradient(180deg, #ffffff 0%, #f0f8ff 100%);
        }
        .bg-冬至 { /* 冬至 - Winter Solstice */
            background:
                radial-gradient(ellipse at 50% 90%, rgba(70, 130, 180, 0.25) 0%, transparent 50%),
                radial-gradient(circle at 25% 25%, rgba(100, 149, 237, 0.2) 0%, transparent 40%),
                radial-gradient(circle at 75% 25%, rgba(65, 105, 225, 0.2) 0%, transparent 40%),
                linear-gradient(to top, #e6f0ff 0%, #f0f4ff 100%);
        }
        .bg-小寒 { /* 小寒 - Minor Cold */
            background:
                radial-gradient(circle at 30% 70%, rgba(135, 206, 235, 0.3) 0%, transparent 45%),
                radial-gradient(circle at 70% 30%, rgba(176, 224, 230, 0.25) 0%, transparent 40%),
                linear-gradient(135deg, #e6f3ff 0%, #e0f0ff 100%);
        }
        .bg-大寒 { /* 大寒 - Major Cold */
            background:
                radial-gradient(ellipse at 50% 50%, rgba(112, 128, 144, 0.2) 0%, transparent 60%),
                radial-gradient(circle at 10% 90%, rgba(119, 136, 153, 0.25) 0%, transparent 40%),
                radial-gradient(circle at 90% 10%, rgba(176, 196, 222, 0.25) 0%, transparent 40%),
                linear-gradient(135deg, #e8ecf0 0%, #e0e8f0 100%);
        }
        
        /* 共通背景スタイル */
        [class*="bg-"] {
            position: relative;
            overflow: hidden;
            transition: all 1s ease;
        }
        
        /* 季節のアニメーション背景 */
        .season-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            overflow: hidden;
        }
        
        /* 冬 - 小寒 */
        .ice-crystal {
            position: absolute;
            width: 20px;
            height: 20px;
            opacity: 0;
            animation: gentleSnowDrift 8s linear infinite;
        }
        .ice-crystal::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(173, 216, 230, 0.5);
        }
        .ice-crystal::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(60deg);
        }
        
        /* 冬 - 大寒 */
        .icicle {
            position: absolute;
            width: 3px;
            height: 40px;
            background: linear-gradient(to bottom, rgba(200,230,255,0.9), rgba(255,255,255,0.6));
            border-radius: 0 0 50% 50%;
            opacity: 0;
            animation: icicleForm 10s ease-in-out infinite;
            transform-origin: top;
        }
        .water-drop {
            position: absolute;
            width: 6px;
            height: 8px;
            background: radial-gradient(circle at 30% 30%, rgba(135, 206, 250, 0.8), rgba(100, 149, 237, 0.6));
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            opacity: 0;
            animation: dropFall 3s ease-in infinite;
        }
        
        /* 春 - 立春 */
        .plum-blossom {
            position: absolute;
            width: 25px;
            height: 25px;
            opacity: 0;
            animation: blossomBloom 6s ease-in-out infinite;
        }
        .plum-blossom::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #ffb3ba 0%, #ff6b9d 70%);
            border-radius: 50% 0;
            transform: rotate(0deg);
        }
        .plum-blossom::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #ffb3ba 0%, #ff6b9d 70%);
            border-radius: 50% 0;
            transform: rotate(72deg);
        }
        
        /* 春 - 雨水 */
        .rain-drop {
            position: absolute;
            width: 4px;
            height: 15px;
            background: linear-gradient(to bottom, transparent, rgba(135, 206, 250, 0.6));
            border-radius: 0 0 50% 50%;
            opacity: 0;
            animation: springRain 2s linear infinite;
        }
        .sprout {
            position: absolute;
            width: 10px;
            height: 20px;
            background: linear-gradient(to top, #228b22, #90ee90);
            border-radius: 0 100% 0 100%;
            transform-origin: bottom;
            opacity: 0;
            animation: sproutGrow 5s ease-out infinite;
        }
        
        /* 春 - 啓蟄 */
        .soil-mound {
            position: absolute;
            width: 40px;
            height: 20px;
            background: radial-gradient(ellipse at center, #8b4513, #a0522d);
            border-radius: 50% 50% 0 0;
            opacity: 0;
            animation: moundPulse 4s ease-in-out infinite;
        }
        .insect {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #333;
            border-radius: 50%;
            opacity: 0;
            animation: insectCrawl 6s ease-in-out infinite;
        }
        
        /* 春 - 春分 */
        .swallow {
            position: absolute;
            width: 30px;
            height: 20px;
            opacity: 0;
            animation: swallowFly 8s ease-in-out infinite;
        }
        .swallow::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 3px;
            background: #333;
            transform: rotate(-20deg);
            top: 50%;
        }
        .swallow::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 3px;
            background: #333;
            transform: rotate(20deg);
            top: 50%;
        }
        
        /* 春 - 清明 */
        .sakura-petal {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle at 30% 30%, #ffb7c5 0%, #ffc0cb 50%, rgba(255, 192, 203, 0.8) 100%);
            border-radius: 0 100% 0 100%;
            opacity: 0;
            animation: sakuraFall 5s linear infinite;
        }
        .young-leaf {
            position: absolute;
            width: 15px;
            height: 20px;
            background: linear-gradient(135deg, #90ee90, #228b22);
            border-radius: 0 100% 0 100%;
            opacity: 0;
            animation: leafFloat 6s ease-in-out infinite;
        }
        
        /* 春 - 穀雨 */
        .grain-rain {
            position: absolute;
            width: 3px;
            height: 20px;
            background: linear-gradient(to bottom, transparent, rgba(70, 130, 180, 0.6));
            opacity: 0;
            animation: gentleRain 1.5s linear infinite;
        }
        .ripple {
            position: absolute;
            width: 20px;
            height: 10px;
            border: 2px solid rgba(70, 130, 180, 0.4);
            border-radius: 50%;
            opacity: 0;
            animation: waterRipple 3s ease-out infinite;
        }
        
        /* 夏 - 立夏 */
        .fresh-green {
            position: absolute;
            width: 25px;
            height: 30px;
            background: linear-gradient(to top, #228b22, #32cd32, #00ff00);
            border-radius: 0 80% 0 80%;
            opacity: 0;
            animation: leafDance 4s ease-in-out infinite;
        }
        .frog {
            position: absolute;
            width: 15px;
            height: 15px;
            background: radial-gradient(circle, #228b22, #006400);
            border-radius: 50%;
            opacity: 0;
            animation: frogJump 3s ease-in-out infinite;
        }
        
        /* 夏 - 小満 */
        .wheat-stalk {
            position: absolute;
            width: 3px;
            height: 40px;
            background: linear-gradient(to top, #8b7355, #daa520);
            opacity: 0;
            animation: wheatWave 3s ease-in-out infinite;
            transform-origin: bottom;
        }
        .wheat-grain {
            position: absolute;
            width: 8px;
            height: 12px;
            background: radial-gradient(ellipse, #ffd700, #daa520);
            border-radius: 50%;
            top: -12px;
            left: -2.5px;
        }
        
        /* 夏 - 芒種 */
        .rice-seedling {
            position: absolute;
            width: 2px;
            height: 30px;
            background: linear-gradient(to top, #3cb371, #90ee90);
            opacity: 0;
            animation: seedlingGrow 4s ease-out infinite;
            transform-origin: bottom;
        }
        .water-reflection {
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(135, 206, 250, 0.5), transparent);
            opacity: 0;
            animation: waterShimmer 2s linear infinite;
        }
        
        /* 夏 - 夏至 */
        .cumulonimbus {
            position: absolute;
            width: 80px;
            height: 60px;
            background: radial-gradient(ellipse at center bottom, #fff, #e0e0e0);
            border-radius: 50%;
            opacity: 0;
            animation: cloudGrow 8s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        .lightning {
            position: absolute;
            width: 2px;
            height: 40px;
            background: linear-gradient(to bottom, #ffeb3b, #fff);
            opacity: 0;
            animation: lightningFlash 6s ease-in-out infinite;
            clip-path: polygon(40% 0, 60% 40%, 100% 45%, 0 100%, 30% 60%, 0 55%);
        }
        
        /* 夏 - 小暑 */
        .wind-chime {
            position: absolute;
            width: 30px;
            height: 40px;
            opacity: 0;
            animation: chimeSwing 3s ease-in-out infinite;
            transform-origin: top;
        }
        .wind-chime::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #4169e1, #1e90ff);
            border-radius: 50% 50% 80% 80%;
            top: 0;
            left: 5px;
        }
        .wind-chime::after {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            background: #fff;
            top: 25px;
            left: 7.5px;
            border-radius: 0 0 50% 50%;
        }
        
        /* 夏 - 大暑 */
        .heat-wave {
            position: absolute;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, transparent, rgba(255, 69, 0, 0.3), transparent);
            opacity: 0;
            animation: heatShimmer 2s ease-in-out infinite;
        }
        .cicada {
            position: absolute;
            width: 15px;
            height: 25px;
            background: linear-gradient(to bottom, #8b4513, #d2691e);
            border-radius: 50% 50% 40% 40%;
            opacity: 0;
            animation: cicadaPulse 1s ease-in-out infinite;
        }
        
        /* 秋 - 立秋 */
        .sunset-cloud {
            position: absolute;
            width: 60px;
            height: 20px;
            background: linear-gradient(to right, #ff6b6b, #ff8c42, #ffd93d);
            border-radius: 50px;
            opacity: 0;
            animation: cloudDrift 10s linear infinite;
        }
        .dragonfly {
            position: absolute;
            width: 30px;
            height: 4px;
            background: #4169e1;
            opacity: 0;
            animation: dragonflyFlight 5s ease-in-out infinite;
        }
        .dragonfly::before,
        .dragonfly::after {
            content: '';
            position: absolute;
            width: 15px;
            height: 10px;
            background: rgba(135, 206, 250, 0.5);
            border-radius: 50%;
            top: -3px;
        }
        .dragonfly::before { left: -5px; }
        .dragonfly::after { right: -5px; }
        
        /* 秋 - 処暑 */
        .rice-ear {
            position: absolute;
            width: 4px;
            height: 50px;
            background: linear-gradient(to top, #8b7355, #daa520);
            opacity: 0;
            animation: riceBow 4s ease-in-out infinite;
            transform-origin: bottom;
        }
        .rice-ear::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 15px;
            background: radial-gradient(ellipse, #ffd700, #daa520);
            border-radius: 50%;
            top: -10px;
            left: -8px;
            transform: rotate(15deg);
        }
        
        /* 秋 - 白露 */
        .dew-drop {
            position: absolute;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.9), rgba(220, 220, 220, 0.6));
            border-radius: 50%;
            opacity: 0;
            animation: dewTremble 3s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        /* 秋 - 秋分 */
        .red-spider-lily {
            position: absolute;
            width: 30px;
            height: 40px;
            opacity: 0;
            animation: lilyBloom 6s ease-in-out infinite;
        }
        .red-spider-lily::before {
            content: '';
            position: absolute;
            width: 3px;
            height: 100%;
            background: #228b22;
            left: 50%;
            transform: translateX(-50%);
        }
        .red-spider-lily::after {
            content: '';
            position: absolute;
            width: 30px;
            height: 20px;
            background: radial-gradient(circle, #dc143c, #ff0000);
            border-radius: 0 0 50% 50%;
            top: 0;
            clip-path: polygon(50% 0%, 0% 100%, 20% 100%, 50% 30%, 80% 100%, 100% 100%);
        }
        
        /* 秋 - 寒露 */
        .wild-geese {
            position: absolute;
            width: 100px;
            height: 50px;
            opacity: 0;
            animation: geeseFly 12s linear infinite;
        }
        .wild-geese::before,
        .wild-geese::after {
            content: 'V';
            position: absolute;
            font-size: 20px;
            color: #333;
            transform: scaleX(3) scaleY(0.5);
        }
        .wild-geese::before { left: 0; }
        .wild-geese::after { left: 30px; top: -10px; }
        
        /* 秋 - 霜降 */
        .autumn-leaf {
            position: absolute;
            width: 25px;
            height: 25px;
            background: linear-gradient(135deg, #d2691e 0%, #ff6347 50%, #ff8c00 100%);
            clip-path: polygon(50% 0%, 60% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 40% 35%);
            opacity: 0;
            animation: autumnFall 5s linear infinite;
        }
        .frost {
            position: absolute;
            width: 15px;
            height: 15px;
            background: radial-gradient(circle, rgba(255,255,255,0.9), transparent);
            opacity: 0;
            animation: frostForm 4s ease-in-out infinite;
        }
        
        /* 冬 - 立冬 */
        .bare-branch {
            position: absolute;
            width: 60px;
            height: 40px;
            opacity: 0;
            animation: branchSway 8s ease-in-out infinite;
        }
        .bare-branch::before {
            content: '';
            position: absolute;
            width: 3px;
            height: 100%;
            background: #8b4513;
            transform: rotate(-30deg);
            transform-origin: bottom;
        }
        .bare-branch::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 60%;
            background: #8b4513;
            transform: rotate(45deg);
            transform-origin: bottom;
            left: 20px;
        }
        
        /* 冬 - 小雪 */
        .light-snow {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, rgba(255,255,255,0.9), rgba(240,248,255,0.7));
            border-radius: 50%;
            opacity: 0;
            animation: lightSnowFall 6s linear infinite;
        }
        
        /* 冬 - 大雪 */
        .heavy-snow {
            position: absolute;
            width: 15px;
            height: 15px;
            background: radial-gradient(circle, #fff, rgba(240,248,255,0.8));
            border-radius: 50%;
            opacity: 0;
            animation: heavySnowFall 4s linear infinite;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        /* 冬 - 冬至 */
        .candle-flame {
            position: absolute;
            width: 20px;
            height: 30px;
            background: radial-gradient(ellipse at bottom, #ff6347, #ff8c00, transparent);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            opacity: 0;
            animation: flameFlicker 2s ease-in-out infinite;
            transform-origin: bottom;
        }
        .yuzu {
            position: absolute;
            width: 25px;
            height: 25px;
            background: radial-gradient(circle at 30% 30%, #ffd700, #ffa500);
            border-radius: 50%;
            opacity: 0;
            animation: yuzuFloat 5s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(255,215,0,0.3);
        }
        
        /* 冬のアニメーション */
        @keyframes gentleSnowDrift {
            0% { transform: translateY(-20px) translateX(0) rotate(0deg); opacity: 0; }
            10% { opacity: 0.8; }
            100% { transform: translateY(calc(100vh + 20px)) translateX(50px) rotate(360deg); opacity: 0; }
        }
        @keyframes icicleForm {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(1.1); }
        }
        @keyframes dropFall {
            0% { transform: translateY(0); opacity: 0; }
            10% { opacity: 1; }
            100% { transform: translateY(100vh); opacity: 0; }
        }
        
        /* 春のアニメーション */
        @keyframes blossomBloom {
            0%, 100% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(1) rotate(180deg); opacity: 0.8; }
        }
        @keyframes springRain {
            0% { transform: translateY(-10px); opacity: 0; }
            10% { opacity: 0.6; }
            100% { transform: translateY(100vh); opacity: 0; }
        }
        @keyframes sproutGrow {
            0% { transform: scaleY(0); opacity: 0; }
            50% { transform: scaleY(1); opacity: 0.8; }
            100% { transform: scaleY(1) rotate(5deg); opacity: 0.6; }
        }
        @keyframes moundPulse {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        @keyframes insectCrawl {
            0% { transform: translateX(-50px); opacity: 0; }
            50% { transform: translateX(50px); opacity: 0.8; }
            100% { transform: translateX(150px); opacity: 0; }
        }
        @keyframes swallowFly {
            0% { transform: translateX(-100px) translateY(0); opacity: 0; }
            50% { transform: translateX(50vw) translateY(-20px); opacity: 0.8; }
            100% { transform: translateX(100vw) translateY(0); opacity: 0; }
        }
        @keyframes sakuraFall {
            0% { transform: translateY(-20px) translateX(0) rotate(-45deg); opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.8; }
            100% { transform: translateY(calc(100vh + 20px)) translateX(100px) rotate(315deg); opacity: 0; }
        }
        @keyframes leafFloat {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-30px) rotate(180deg); }
        }
        @keyframes gentleRain {
            0% { transform: translateY(-10px); opacity: 0; }
            100% { transform: translateY(100vh); opacity: 0.6; }
        }
        @keyframes waterRipple {
            0% { transform: scale(0); opacity: 0.8; }
            100% { transform: scale(3); opacity: 0; }
        }
        
        /* 夏のアニメーション */
        @keyframes leafDance {
            0%, 100% { transform: rotate(-5deg); opacity: 0.8; }
            50% { transform: rotate(5deg); opacity: 0.9; }
        }
        @keyframes frogJump {
            0%, 100% { transform: translateY(0); opacity: 0.7; }
            50% { transform: translateY(-30px); opacity: 0.9; }
        }
        @keyframes wheatWave {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }
        @keyframes seedlingGrow {
            0% { transform: scaleY(0); opacity: 0; }
            100% { transform: scaleY(1); opacity: 0.8; }
        }
        @keyframes waterShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        @keyframes cloudGrow {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 0.9; }
        }
        @keyframes lightningFlash {
            0%, 90%, 100% { opacity: 0; }
            92%, 95% { opacity: 1; }
        }
        @keyframes chimeSwing {
            0%, 100% { transform: rotate(-10deg); }
            50% { transform: rotate(10deg); }
        }
        @keyframes heatShimmer {
            0%, 100% { transform: scaleY(1); opacity: 0.3; }
            50% { transform: scaleY(1.5); opacity: 0.5; }
        }
        @keyframes cicadaPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }
        
        /* 秋のアニメーション */
        @keyframes cloudDrift {
            0% { transform: translateX(-100px); opacity: 0; }
            10% { opacity: 0.7; }
            90% { opacity: 0.7; }
            100% { transform: translateX(100vw); opacity: 0; }
        }
        @keyframes dragonflyFlight {
            0% { transform: translateX(-50px) translateY(0); opacity: 0; }
            25% { transform: translateX(25vw) translateY(-10px); opacity: 0.8; }
            50% { transform: translateX(50vw) translateY(0); opacity: 0.8; }
            75% { transform: translateX(75vw) translateY(10px); opacity: 0.8; }
            100% { transform: translateX(100vw) translateY(0); opacity: 0; }
        }
        @keyframes riceBow {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(-10deg); }
        }
        @keyframes dewTremble {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(2px); }
        }
        @keyframes lilyBloom {
            0%, 100% { transform: scale(0.8) rotate(0deg); opacity: 0; }
            50% { transform: scale(1) rotate(5deg); opacity: 0.9; }
        }
        @keyframes geeseFly {
            0% { transform: translateX(-100px) translateY(0); opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.8; }
            100% { transform: translateX(100vw) translateY(-50px); opacity: 0; }
        }
        @keyframes autumnFall {
            0% { transform: translateY(-30px) translateX(0) rotate(0deg); opacity: 0; }
            10% { opacity: 0.9; }
            90% { opacity: 0.9; }
            100% { transform: translateY(calc(100vh + 30px)) translateX(-80px) rotate(360deg); opacity: 0; }
        }
        @keyframes frostForm {
            0%, 100% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1); opacity: 0.6; }
        }
        @keyframes branchSway {
            0%, 100% { transform: rotate(-2deg); }
            50% { transform: rotate(2deg); }
        }
        @keyframes lightSnowFall {
            0% { transform: translateY(-20px) translateX(0); opacity: 0; }
            10% { opacity: 0.7; }
            100% { transform: translateY(100vh) translateX(20px); opacity: 0; }
        }
        @keyframes heavySnowFall {
            0% { transform: translateY(-30px); opacity: 0; }
            10% { opacity: 0.9; }
            100% { transform: translateY(100vh); opacity: 0.7; }
        }
        @keyframes flameFlicker {
            0%, 100% { transform: scaleY(1) scaleX(1); opacity: 0.8; }
            50% { transform: scaleY(1.1) scaleX(0.9); opacity: 0.9; }
        }
        @keyframes yuzuFloat {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(180deg); }
        }
        
        /* 波紋エフェクト */
        @keyframes ripple {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(4); opacity: 0; }
        }
        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            animation: ripple 1s ease-out;
        }
        
        /* 和紙風カード */
        .washi-card {
            background: repeating-linear-gradient(90deg, rgba(255,255,255,0.9), rgba(255,255,255,0.9) 1px, rgba(255,255,255,0.95) 1px, rgba(255,255,255,0.95) 3px), rgba(255,255,255,0.92);
            backdrop-filter: blur(8px);
            box-shadow: 0 3px 12px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.5);  
            border: 1px solid rgba(0,0,0,0.08);  
        }
        
        /* スマホ用調整 */
        @media (max-width: 640px) {
            .task-text-lg { font-size: 1.05rem; line-height: 1.55; }  
            .button-large { min-height: 48px; font-size: 1rem; }
            .sekki-grid { grid-template-columns: repeat(3, 1fr) !important; }
            .mobile-compact { padding: 0.75rem !important; }
            .mobile-text-sm { font-size: 0.875rem !important; }
            .mobile-gap-2 { gap: 0.5rem !important; }
            .point-display-mobile { 
                flex-direction: column !important; 
                align-items: flex-start !important;
                gap: 0.5rem !important;
            }
        }
        
        @media (hover: none) {
            .wa-button:active { transform: scale(0.95); }
        }
        
        /* ポイント選択ボタン */
        .point-select-button {
            position: relative;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        .point-select-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .point-select-button:active {
            transform: translateY(0);
        }
        
        /* 日付表示の強調 */
        #calendarToggle {
            min-width: 120px;
            position: relative;
        }
        #calendarToggle.bg-amber-50::after {
            content: '今日';
            position: absolute;
            top: -8px;
            right: -8px;
            background: #f59e0b;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
        }
        
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fadeInUp { animation: fadeInUp 0.8s ease-out forwards; }
        
        /* チェックボックス */
        .wa-checkbox {
            border: 2px solid #8b7355;
            position: relative;
            transition: all 0.3s ease;
            min-width: 44px;
            min-height: 44px;
            -webkit-tap-highlight-color: transparent;
        }
        .wa-checkbox.checked { background-color: #8b7355; border-color: #8b7355; }
        .wa-checkbox.checked::after {
            content: ''; position: absolute; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3'%3E%3Cpath d='M5 13l4 4L19 7'/%3E%3C/svg%3E");
            background-size: 70%; background-position: center; background-repeat: no-repeat;
        }
        
        .hidden { display: none; }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .gradient-animation { background-size: 200% 200%; animation: gradientShift 15s ease infinite; }

        /* --- タスク表示改善のためのスタイル --- */
        .task-card {  
             box-shadow: 0 4px 15px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.5);  
        }
        .task-text-lg {  
            font-size: 1.1rem;  
            line-height: 1.6;
        }
        .task-type-label {  
            font-size: 0.8rem;  
            padding: 2px 6px;
            border-radius: 0.375rem; /* rounded-md */
        }
        
        /* 未完了の通常タスク */
        .task-normal-active {
            background-color: #FEFBF3; /* 温かみのあるクリーム色 */
            border: 1px solid #D4C2AD; /* やや濃いめの枠線 */
            box-shadow: 0 3px 8px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.6);
        }
        .task-normal-active .task-text-lg {
            color: #5D4037; /* 濃い茶色の文字 */
        }
        .task-normal-active .task-type-label {
            background-color: #E0D8CC; /* カードに合わせたベージュ */
            color: #6A5ACD; /* SlateBlue 文字 */
            font-weight: 500;
        }

        /* 未完了の目標タスク */
        .task-urgent-active {
            background-color: rgba(255, 235, 224, 0.98); /* 薄いオレンジ */
            border: 2px solid #FF8C69; /* やや濃いオレンジの枠線 */
        }
         .task-urgent-active .task-text-lg {
            color: #BF360C; /* 深いオレンジ/茶色の文字 */
        }
        .task-urgent-active .task-type-label {
            background-color: #FF4500; /* 明るい赤オレンジ */
            color: white;
            font-weight: bold;
        }

        /* 完了済みタスク */
        .task-completed {
            background-color: rgba(236, 253, 245, 0.95);  
            border: 2px solid #10b981;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.15);
            position: relative;
            overflow: hidden;
        }
        .task-completed::before {
            content: '✓';
            position: absolute;
            top: -5px;
            right: 10px;
            font-size: 3rem;
            color: rgba(16, 185, 129, 0.2);
            font-weight: bold;
        }
        .task-completed .task-text-lg {
            color: #059669;
            font-weight: 500;
        }
        .task-completed .task-type-label {
             background-color: #10b981;
             color: white;
             font-weight: bold;
        }
        .task-completed-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background-color: #10b981;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="backgroundSeason" class="min-h-screen bg-summer gradient-animation transition-all duration-1000 relative">
        <!-- 季節のアニメーション -->
        <div id="seasonAnimation" class="season-animation"></div>
        
        <div class="max-w-2xl mx-auto px-4 py-4 relative z-10">
            <!-- 節気ヘッダー -->
            <div class="washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp">
                <div class="text-center mb-4">
                    <h1 class="text-3xl sm:text-5xl font-bold text-gray-800 mb-2 sekki-title">
                        <span id="currentSekki"></span>
                    </h1>
                    <div class="text-base sm:text-lg text-gray-700 mb-1">
                        <span id="sekkiDate"></span>
                    </div>
                    <div id="nextSekkiInfo" class="text-sm text-gray-600"></div>
                    <!-- 今日の日付を大きく表示 -->
                    <div class="mt-4 p-4 bg-amber-50 rounded-lg border-2 border-amber-400">
                        <div class="text-sm text-gray-600" id="todayDateYear"></div>
                        <div class="text-3xl sm:text-4xl font-bold text-gray-800" id="todayDateFull"></div>
                        <div class="text-base text-gray-600" id="todayDateDay"></div>
                    </div>
                </div>
                
                <div class="flex items-center justify-between mb-3">
                    <h2 class="text-lg sm:text-xl font-semibold text-gray-800">本日の予定</h2>
                    <div class="flex items-center gap-2">
                        <button id="statsToggle" class="p-3 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-lg transition-all" title="ポイント統計">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                            </svg>
                        </button>
                        <button id="inboxToggle" class="p-3 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-lg transition-all">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <!-- 日付選択 -->
                <div class="flex flex-col gap-3">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-1">
                            <button id="prevDay" class="p-3 hover:bg-gray-100 rounded-full transition-all">
                                <svg class="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                                </svg>
                            </button>
                            
                            <div id="calendarToggle" class="flex flex-col items-center px-3 sm:px-6 py-2 rounded-2xl border-2 border-gray-300">
                                <span id="currentDateYear" class="text-xs text-gray-600"></span>
                                <span id="currentDate" class="text-lg sm:text-xl font-bold text-gray-800"></span>
                                <span id="currentDateDay" class="text-xs text-gray-600"></span>
                            </div>
                            
                            <button id="nextDay" class="p-3 hover:bg-gray-100 rounded-full transition-all">
                                <svg class="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                </svg>
                            </button>
                        </div>
                        
                        <div class="flex items-center gap-3 point-display-mobile">
                            <div class="flex items-center gap-2 bg-gray-50 px-3 sm:px-4 py-2 rounded-full">
                                <span id="completedCount" class="text-xl sm:text-3xl font-bold text-gray-800">0</span>
                                <span class="text-base sm:text-xl text-gray-500">／</span>
                                <span id="totalCount" class="text-lg sm:text-2xl text-gray-700">0</span>
                            </div>
                            <div class="flex items-center gap-2 bg-amber-50 px-3 sm:px-4 py-2 rounded-full">
                                <svg class="w-4 sm:w-5 h-4 sm:h-5 text-amber-600" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                                </svg>
                                <span id="totalPointsDisplay" class="text-base sm:text-xl font-bold text-amber-700">0</span>
                                <span class="text-sm text-amber-600">pt</span>
                            </div>
                        </div>
                    </div>
                    
                    <button id="todayButton" class="hidden w-full py-3 text-base font-medium text-white bg-gradient-to-r from-gray-700 to-gray-800 hover:from-gray-800 hover:to-gray-900 rounded-full transition-all button-large">
                        本日へ戻る
                    </button>
                </div>
                
                <!-- カレンダー -->
                <div id="calendarInput" class="mt-4 animate-fadeInUp">
                    <input type="date" id="dateInput" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 transition-all text-base">
                    <div id="calendarSekkiInfo" class="mt-3 p-3 bg-gray-50 rounded-lg text-sm text-gray-600"></div>
                </div>
            </div>

            <!-- エラーメッセージ -->
            <div id="errorMessage" class="hidden bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-4 animate-fadeInUp"></div>

            <!-- 期限付きタスク -->
            <div class="washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp" style="animation-delay: 0.1s">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-base sm:text-lg font-semibold text-gray-800">期限付きタスク</h3>
                    <button id="deadlineToggle" class="p-3 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-full transition-all">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                        </svg>
                    </button>
                </div>

                <div id="deadlineForm" class="hidden mb-4 p-3 bg-gray-50 rounded-xl animate-fadeInUp">
                    <div class="flex flex-col gap-3">
                        <input type="text" id="deadlineText" placeholder="タスク内容..." class="px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 transition-all text-base">
                        <div class="flex gap-2">
                            <input type="date" id="deadlineDate" class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 transition-all text-base">
                            <button id="addDeadline" class="px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-800 transition-all">追加</button>
                            <button id="cancelDeadline" class="px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-lg transition-all">×</button>
                        </div>
                    </div>
                </div>

                <div id="deadlineList" class="space-y-2"></div>
                <p id="noDeadlineTasks" class="text-center py-4 text-gray-500 text-sm">期限付きタスクはありません</p>
            </div>

            <!-- タスク入力 -->
            <div class="washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp" style="animation-delay: 0.2s">
                <div class="flex gap-2 mb-3">
                    <button id="normalType" class="flex-1 px-4 py-2 rounded-full font-medium transition-all bg-gray-800 text-white button-large">
                        通常 <span class="text-sm opacity-80">(<span id="normalSlots">3</span>/3)</span>
                    </button>
                    <button id="urgentType" class="flex-1 px-4 py-2 rounded-full font-medium transition-all bg-gray-100 text-gray-700 hover:bg-gray-200 button-large">
                        目標 <span class="text-sm opacity-80">(<span id="urgentSlots">3</span>/3)</span>
                    </button>
                </div>
                
                <div class="flex flex-col gap-2">
                    <input type="text" id="taskInput" placeholder="本日の予定を入力..." class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 transition-all text-base">
                    <div id="pointSelector" class="hidden">
                        <div class="flex items-center gap-2 mb-2">
                            <span class="text-sm font-medium text-gray-700">ポイントを選択:</span>
                        </div>
                        <div class="grid grid-cols-3 gap-2">
                            <button class="point-select-button px-4 py-3 rounded-lg border-2 border-gray-300 hover:border-gray-400 transition-all" data-points="1">
                                <div class="text-lg font-bold">1pt</div>
                                <div class="text-xs text-gray-600">簡単</div>
                            </button>
                            <button class="point-select-button px-4 py-3 rounded-lg border-2 border-gray-300 hover:border-gray-400 transition-all" data-points="2">
                                <div class="text-lg font-bold">2pt</div>
                                <div class="text-xs text-gray-600">普通</div>
                            </button>
                            <button class="point-select-button px-4 py-3 rounded-lg border-2 border-gray-300 hover:border-gray-400 transition-all" data-points="3">
                                <div class="text-lg font-bold">3pt</div>
                                <div class="text-xs text-gray-600">難しい</div>
                            </button>
                        </div>
                    </div>
                    <button id="addTask" class="px-6 py-3 bg-gray-800 text-white rounded-lg hover:bg-gray-900 transition-all font-medium button-large">
                        <svg class="w-5 h-5 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- タスクリスト -->
            <div id="taskList" class="space-y-3 mb-4"></div>
            <p id="noTasks" class="hidden text-center py-8 text-gray-500">本日の予定はありません</p>

            <!-- 日々の振り返り -->
            <div class="washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-base sm:text-lg font-semibold text-gray-800">今日の振り返り</h3>
                    <button id="reflectionToggle" class="p-3 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-full transition-all">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
                        </svg>
                    </button>
                </div>
                
                <div id="reflectionForm" class="hidden space-y-3">
                    <textarea id="reflectionInput" placeholder="今日はどんな一日でしたか？短くても大丈夫です..." 
                              class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 transition-all text-base resize-none" 
                              rows="3"></textarea>
                    <div class="flex gap-2">
                        <button id="saveReflection" class="px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-800 transition-all">保存</button>
                        <button id="cancelReflection" class="px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-lg transition-all">キャンセル</button>
                    </div>
                </div>
                
                <div id="reflectionDisplay" class="text-sm sm:text-base text-gray-700 leading-relaxed"></div>
                <p id="noReflection" class="text-center py-4 text-gray-500 text-sm">まだ振り返りが書かれていません</p>
            </div>

            <!-- ポイント統計 -->
            <div id="statsSection" class="hidden washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp">
                <h3 class="text-base sm:text-lg font-semibold text-gray-800 mb-4">ポイント統計</h3>
                <div class="space-y-4">
                    <div class="bg-amber-50 rounded-lg p-4">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-medium text-gray-700">累計ポイント</span>
                            <div class="flex items-center gap-2">
                                <svg class="w-6 h-6 text-amber-600" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                                </svg>
                                <span class="text-2xl font-bold text-amber-700" id="totalPointsStats">0</span>
                                <span class="text-lg text-amber-600">pt</span>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h4 class="text-sm font-medium text-gray-700 mb-2">最近7日間の獲得ポイント</h4>
                        <div id="weeklyStats" class="space-y-2">
                            <!-- 週間統計がここに表示されます -->
                        </div>
                    </div>
                    
                    <div class="border-t pt-3">
                        <button id="resetStats" class="w-full px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-all text-sm font-medium">
                            統計をリセット
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- アイデア置き場 -->
            <div id="inboxSection" class="hidden washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp">
                <h3 class="text-base sm:text-lg font-semibold text-gray-800 mb-3">覚書</h3>
                <div class="flex gap-2 mb-3">
                    <input type="text" id="inboxInput" placeholder="思いついたことをメモ..." class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 transition-all text-base">
                    <button id="addInbox" class="px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-800 transition-all">記録</button>
                </div>
                <div id="inboxList" class="space-y-2"></div>
            </div>
            
            <!-- AIコメント -->
            <div id="aiCommentSection" class="washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-base sm:text-lg font-semibold text-gray-800">AIからのメッセージ</h3>
                    <button id="aiSettingsToggle" class="p-2 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-lg transition-all text-sm">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                        </svg>
                    </button>
                </div>
                
                <!-- APIキー設定 -->
                <div id="apiKeyForm" class="hidden mb-4 p-3 bg-gray-50 rounded-xl">
                    <label class="block text-sm font-medium text-gray-700 mb-2">OpenAI APIキー</label>
                    <input type="password" id="apiKeyInput" placeholder="sk-..." 
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 text-sm">
                    <div class="flex gap-2 mt-2">
                        <button id="saveApiKey" class="px-3 py-1 bg-gray-700 text-white rounded text-sm">保存</button>
                        <button id="cancelApiKey" class="px-3 py-1 text-gray-700 hover:bg-gray-100 rounded text-sm">キャンセル</button>
                    </div>
                </div>
                
                <!-- 期間選択 -->
                <div id="aiPeriodSelector" class="flex flex-wrap gap-2 mb-3">
                    <button class="ai-period-button px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 hover:bg-gray-300" data-period="daily">デイリー</button>
                    <button class="ai-period-button px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 hover:bg-gray-300" data-period="weekly">週間</button>
                    <button class="ai-period-button px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 hover:bg-gray-300" data-period="sekki">節気間</button>
                    <button class="ai-period-button px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 hover:bg-gray-300" data-period="monthly">月間</button>
                    <button class="ai-period-button px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 hover:bg-gray-300" data-period="quarterly">3ヶ月</button>
                </div>
                
                <!-- AIコメント表示 -->
                <div id="aiCommentDisplay" class="bg-gradient-to-br from-blue-50 to-purple-50 rounded-lg p-4">
                    <div id="aiCommentContent" class="text-sm sm:text-base text-gray-700 leading-relaxed whitespace-pre-wrap max-h-96 overflow-y-auto"></div>
                    <div id="aiCommentLoading" class="hidden text-center py-8">
                        <div class="inline-flex items-center gap-2 text-gray-600">
                            <svg class="animate-spin h-5 w-5" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span>AIがコメントを作成中...</span>
                        </div>
                    </div>
                    <p id="noApiKey" class="text-center py-4 text-gray-500 text-sm">APIキーを設定してAIコメントを受け取りましょう</p>
                </div>
            </div>
            
            <!-- 節気の説明 -->
            <div class="washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp">
                <h3 class="text-base sm:text-lg font-semibold text-gray-800 mb-3 text-center">二十四節気</h3>
                <div class="text-center mb-3">
                    <span id="sekkiDetailName" class="text-xl sm:text-2xl font-bold text-gray-800 sekki-title"></span>
                    <div id="sekkiDetailDate" class="text-xs sm:text-sm text-gray-600 mt-1"></div>
                </div>
                <p id="sekkiDescription" class="text-sm sm:text-base text-gray-700 leading-relaxed mb-4"></p>
                <div class="border-t border-gray-200 pt-3">
                    <p class="text-xs sm:text-sm text-gray-600 text-center mb-2">今年の二十四節気</p>
                    <div id="yearSekkiList" class="grid grid-cols-3 sm:grid-cols-4 gap-1 sm:gap-2 text-xs sm:text-sm sekki-grid"></div>
                </div>
            </div>
        </div>

        <!-- セレブレーション -->
        <div id="celebration" class="hidden fixed inset-0 pointer-events-none flex items-center justify-center z-50">
            <div class="relative">
                <div class="absolute inset-0 bg-amber-500 rounded-full animate-ping"></div>
                <div class="relative washi-card rounded-2xl p-8 sm:p-10 animate-fadeInUp">
                    <div class="text-center">
                        <div class="text-3xl sm:text-4xl mb-2 sekki-title">完了</div>
                        <p class="text-lg sm:text-xl text-gray-700">タスク完了</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 先送りエフェクト -->
        <div id="postponeEffect" class="hidden fixed bottom-4 right-4 washi-card rounded-xl p-4 animate-fadeInUp flex items-center gap-2">
            <svg class="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
            </svg>
            <span class="text-base font-medium text-gray-700">明日へ</span>
        </div>
    </div>

    <script>
        // 実際の季節を月から判定する関数
        function getActualSeason(date) {
            const month = date.getMonth() + 1; // 0-11 を 1-12 に変換
            if (month >= 3 && month <= 5) return 'spring';
            if (month >= 6 && month <= 8) return 'summer';
            if (month >= 9 && month <= 11) return 'autumn';
            return 'winter';
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            const now = new Date();
            app.updateSekki();
        });

        const sekkiData = { // Sekki data remains the same
            2025: [
                { name: '小寒', date: new Date('2025-01-05T11:33:00'), season: 'winter', description: '寒さが最も厳しくなる前の時期。この日から寒の入りとなります。' },
                { name: '大寒', date: new Date('2025-01-20T05:00:00'), season: 'winter', description: '一年で最も寒さが厳しい時期。寒稽古など、寒さを利用した行事が行われます。' },
                { name: '立春', date: new Date('2025-02-03T23:10:00'), season: 'spring', description: '暦の上での春の始まり。梅の花が咲き始め、徐々に暖かくなり始めます。' },
                { name: '雨水', date: new Date('2025-02-18T19:07:00'), season: 'spring', description: '雪が雨に変わり、積もった雪が溶け始める頃。農耕の準備を始める目安です。' },
                { name: '啓蟄', date: new Date('2025-03-05T17:07:00'), season: 'spring', description: '冬ごもりしていた虫が、春の暖かさを感じて地中から姿を現す頃。' },
                { name: '春分', date: new Date('2025-03-20T18:01:00'), season: 'spring', description: '昼と夜の長さがほぼ等しくなる日。自然をたたえ生物をいつくしむ日です。' },
                { name: '清明', date: new Date('2025-04-04T21:49:00'), season: 'spring', description: '万物が清らかで明るく、生き生きとした様子を見せる頃。花見の季節です。' },
                { name: '穀雨', date: new Date('2025-04-20T04:56:00'), season: 'spring', description: '春の雨が降り、穀物の成長を助ける頃。種まきの好機とされています。' },
                { name: '立夏', date: new Date('2025-05-05T14:57:00'), season: 'summer', description: '暦の上での夏の始まり。新緑が美しく、過ごしやすい気候になります。' },
                { name: '小満', date: new Date('2025-05-21T03:55:00'), season: 'summer', description: '陽気が良くなり、万物が成長して天地に満ち始める頃。麦の穂が実り始めます。' },
                { name: '芒種', date: new Date('2025-06-05T18:57:00'), season: 'summer', description: '稲などの穀物の種をまく時期。梅雨入りの頃でもあります。' },
                { name: '夏至', date: new Date('2025-06-21T11:42:00'), season: 'summer', description: '一年で最も昼が長く夜が短い日。本格的な夏の到来を告げます。' },
                { name: '小暑', date: new Date('2025-07-07T05:05:00'), season: 'summer', description: '暑さが本格的になる頃。梅雨明けが近づき、蝉が鳴き始めます。' },
                { name: '大暑', date: new Date('2025-07-22T22:29:00'), season: 'summer', description: '一年で最も暑さが厳しい時期。夏の土用の時期でもあります。' },
                { name: '立秋', date: new Date('2025-08-07T14:52:00'), season: 'autumn', description: '暦の上での秋の始まり。まだ暑いですが、朝夕は涼しくなり始めます。' },
                { name: '処暑', date: new Date('2025-08-23T05:34:00'), season: 'autumn', description: '暑さが和らぐ頃。朝晩の涼しさに秋の気配を感じ始めます。' },
                { name: '白露', date: new Date('2025-09-07T17:52:00'), season: 'autumn', description: '草花に朝露が宿り始める頃。日中は暖かくても朝晩は冷え込みます。' },
                { name: '秋分', date: new Date('2025-09-23T03:19:00'), season: 'autumn', description: '昼と夜の長さがほぼ等しくなる日。秋彼岸の中日でもあります。' },
                { name: '寒露', date: new Date('2025-10-08T09:41:00'), season: 'autumn', description: '露が冷たく感じられる頃。秋が深まり、紅葉が美しくなります。' },
                { name: '霜降', date: new Date('2025-10-23T12:51:00'), season: 'autumn', description: '露が霜に変わり始める頃。朝晩の冷え込みが厳しくなります。' },
                { name: '立冬', date: new Date('2025-11-07T13:04:00'), season: 'winter', description: '暦の上での冬の始まり。日差しが弱まり、冬の気配を感じ始めます。' },
                { name: '小雪', date: new Date('2025-11-22T10:36:00'), season: 'winter', description: '雪が降り始める頃。まだ積もるほどではない、わずかな雪を指します。' },
                { name: '大雪', date: new Date('2025-12-07T06:05:00'), season: 'winter', description: '本格的に雪が降り始める頃。山々は雪に覆われ、平地でも雪が降ります。' },
                { name: '冬至', date: new Date('2025-12-22T00:03:00'), season: 'winter', description: '一年で最も昼が短く夜が長い日。ゆず湯に入り、かぼちゃを食べる風習があります。' }
            ],
            2026: [ // Data for 2026 remains for future-proofing
                { name: '小寒', date: new Date('2026-01-05T17:24:00'), season: 'winter', description: '寒さが最も厳しくなる前の時期。この日から寒の入りとなります。' },
                { name: '大寒', date: new Date('2026-01-20T10:46:00'), season: 'winter', description: '一年で最も寒さが厳しい時期。寒稽古など、寒さを利用した行事が行われます。' },
                { name: '立春', date: new Date('2026-02-04T05:03:00'), season: 'spring', description: '暦の上での春の始まり。梅の花が咲き始め、徐々に暖かくなり始めます。' },
                { name: '雨水', date: new Date('2026-02-19T00:51:00'), season: 'spring', description: '雪が雨に変わり、積もった雪が溶け始める頃。農耕の準備を始める目安です。' },
                { name: '啓蟄', date: new Date('2026-03-05T22:58:00'), season: 'spring', description: '冬ごもりしていた虫が、春の暖かさを感じて地中から姿を現す頃。' },
                { name: '春分', date: new Date('2026-03-20T23:41:00'), season: 'spring', description: '昼と夜の長さがほぼ等しくなる日。自然をたたえ生物をいつくしむ日です。' },
                { name: '清明', date: new Date('2026-04-05T03:35:00'), season: 'spring', description: '万物が清らかで明るく、生き生きとした様子を見せる頃。花見の季節です。' },
                { name: '穀雨', date: new Date('2026-04-20T10:31:00'), season: 'spring', description: '春の雨が降り、穀物の成長を助ける頃。種まきの好機とされています。' },
                { name: '立夏', date: new Date('2026-05-05T20:41:00'), season: 'summer', description: '暦の上での夏の始まり。新緑が美しく、過ごしやすい気候になります。' },
                { name: '小満', date: new Date('2026-05-21T09:28:00'), season: 'summer', description: '陽気が良くなり、万物が成長して天地に満ち始める頃。麦の穂が実り始めます。' },
                { name: '芒種', date: new Date('2026-06-06T00:40:00'), season: 'summer', description: '稲などの穀物の種をまく時期。梅雨入りの頃でもあります。' },
                { name: '夏至', date: new Date('2026-06-21T17:16:00'), season: 'summer', description: '一年で最も昼が長く夜が短い日。本格的な夏の到来を告げます。' },
                { name: '小暑', date: new Date('2026-07-07T10:50:00'), season: 'summer', description: '暑さが本格的になる頃。梅雨明けが近づき、蝉が鳴き始めます。' },
                { name: '大暑', date: new Date('2026-07-23T04:07:00'), season: 'summer', description: '一年で最も暑さが厳しい時期。夏の土用の時期でもあります。' },
                { name: '立秋', date: new Date('2026-08-07T20:38:00'), season: 'autumn', description: '暦の上での秋の始まり。まだ暑いですが、朝夕は涼しくなり始めます。' },
                { name: '処暑', date: new Date('2026-08-23T11:16:00'), season: 'autumn', description: '暑さが和らぐ頃。朝晩の涼しさに秋の気配を感じ始めます。' },
                { name: '白露', date: new Date('2026-09-07T23:41:00'), season: 'autumn', description: '草花に朝露が宿り始める頃。日中は暖かくても朝晩は冷え込みます。' },
                { name: '秋分', date: new Date('2026-09-23T09:04:00'), season: 'autumn', description: '昼と夜の長さがほぼ等しくなる日。秋彼岸の中日でもあります。' },
                { name: '寒露', date: new Date('2026-10-08T15:31:00'), season: 'autumn', description: '露が冷たく感じられる頃。秋が深まり、紅葉が美しくなります。' },
                { name: '霜降', date: new Date('2026-10-23T18:38:00'), season: 'autumn', description: '露が霜に変わり始める頃。朝晩の冷え込みが厳しくなります。' },
                { name: '立冬', date: new Date('2026-11-07T18:54:00'), season: 'winter', description: '暦の上での冬の始まり。日差しが弱まり、冬の気配を感じ始めます。' },
                { name: '小雪', date: new Date('2026-11-22T16:24:00'), season: 'winter', description: '雪が降り始める頃。まだ積もるほどではない、わずかな雪を指します。' },
                { name: '大雪', date: new Date('2026-12-07T11:55:00'), season: 'winter', description: '本格的に雪が降り始める頃。山々は雪に覆われ、平地でも雪が降ります。' },
                { name: '冬至', date: new Date('2026-12-22T05:53:00'), season: 'winter', description: '一年で最も昼が短く夜が長い日。ゆず湯に入り、かぼちゃを食べる風習があります。' }
            ]
        };

        function createSeasonalAnimation(sekki) {
            const animationEl = document.getElementById('seasonAnimation');
            if (!animationEl) { console.error('Animation element not found'); return; }
            animationEl.innerHTML = '';
            
            const isMobile = window.innerWidth < 640;
            
            switch(sekki) {
                case '小寒': // 小寒 - Minor Cold
                    createIceCrystals(animationEl, isMobile ? 15 : 30);
                    break;
                case '大寒': // 大寒 - Major Cold
                    createIcicles(animationEl, isMobile ? 8 : 15);
                    break;
                case '立春': // 立春 - Beginning of Spring
                    createPlumBlossoms(animationEl, isMobile ? 10 : 20);
                    break;
                case '雨水': // 雨水 - Rain Water
                    createSpringRain(animationEl, isMobile ? 20 : 40);
                    break;
                case '啓蟄': // 啓蟄 - Awakening of Insects
                    createInsects(animationEl, isMobile ? 5 : 10);
                    break;
                case '春分': // 春分 - Spring Equinox
                    createSwallows(animationEl, isMobile ? 3 : 6);
                    break;
                case '清明': // 清明 - Clear and Bright
                    createSakuraAndLeaves(animationEl, isMobile ? 15 : 30);
                    break;
                case '穀雨': // 穀雨 - Grain Rain
                    createGrainRain(animationEl, isMobile ? 25 : 50);
                    break;
                case '立夏': // 立夏 - Beginning of Summer
                    createFreshGreen(animationEl, isMobile ? 10 : 20);
                    break;
                case '小満': // 小満 - Grain Buds
                    createWheatField(animationEl, isMobile ? 15 : 30);
                    break;
                case '芒種': // 芒種 - Grain in Ear
                    createRiceSeedlings(animationEl, isMobile ? 20 : 40);
                    break;
                case '夏至': // 夏至 - Summer Solstice
                    createCumulonimbus(animationEl, isMobile ? 3 : 5);
                    break;
                case '小暑': // 小暑 - Minor Heat
                    createWindChimes(animationEl, isMobile ? 5 : 10);
                    break;
                case '大暑': // 大暑 - Major Heat
                    createHeatWaves(animationEl, isMobile ? 10 : 20);
                    break;
                case '立秋': // 立秋 - Beginning of Autumn
                    createSunsetClouds(animationEl, isMobile ? 3 : 6);
                    createDragonflies(animationEl, isMobile ? 5 : 10);
                    break;
                case '処暑': // 処暑 - End of Heat
                    createRiceEars(animationEl, isMobile ? 15 : 30);
                    break;
                case '白露': // 白露 - White Dew
                    createDewDrops(animationEl, isMobile ? 20 : 40);
                    break;
                case '秋分': // 秋分 - Autumn Equinox
                    createRedSpiderLilies(animationEl, isMobile ? 8 : 15);
                    break;
                case '寒露': // 寒露 - Cold Dew
                    createWildGeese(animationEl, isMobile ? 2 : 4);
                    break;
                case '霜降': // 霜降 - Frost Descent
                    createAutumnLeaves(animationEl, isMobile ? 15 : 30);
                    createFrost(animationEl, isMobile ? 10 : 20);
                    break;
                case '立冬': // 立冬 - Beginning of Winter
                    createBareBranches(animationEl, isMobile ? 5 : 10);
                    break;
                case '小雪': // 小雪 - Minor Snow
                    createLightSnow(animationEl, isMobile ? 20 : 40);
                    break;
                case '大雪': // 大雪 - Major Snow
                    createHeavySnow(animationEl, isMobile ? 25 : 50);
                    break;
                case '冬至': // 冬至 - Winter Solstice
                    createCandleFlame(animationEl, 1);
                    createYuzu(animationEl, isMobile ? 3 : 6);
                    break;
                default:
                    // Fallback to current season's default animation
                    const season = getActualSeason(new Date());
                    if (season === 'spring') createSakuraAndLeaves(animationEl, isMobile ? 15 : 30);
                    else if (season === 'summer') createFreshGreen(animationEl, isMobile ? 20 : 40);
                    else if (season === 'autumn') createAutumnLeaves(animationEl, isMobile ? 15 : 30);
                    else createLightSnow(animationEl, isMobile ? 20 : 40);
            }
            
            // Add interactive handlers
            setupInteractiveElements(animationEl);
        }
        
        // Individual animation creation functions
        function createIceCrystals(container, count) {
            for (let i = 0; i < count; i++) {
                const crystal = document.createElement('div');
                crystal.className = 'ice-crystal interactive-element';
                crystal.style.left = Math.random() * 100 + '%';
                crystal.style.animationDelay = Math.random() * 5 + 's';
                crystal.style.animationDuration = (8 + Math.random() * 4) + 's';
                container.appendChild(crystal);
            }
        }
        
        function createIcicles(container, count) {
            for (let i = 0; i < count; i++) {
                const icicle = document.createElement('div');
                icicle.className = 'icicle';
                icicle.style.left = (i / count) * 100 + '%';
                icicle.style.height = (30 + Math.random() * 30) + 'px';
                icicle.style.animationDelay = Math.random() * 2 + 's';
                container.appendChild(icicle);
                
                // Occasionally drop water
                if (Math.random() > 0.7) {
                    setTimeout(() => {
                        const drop = document.createElement('div');
                        drop.className = 'water-drop';
                        drop.style.left = icicle.style.left;
                        drop.style.top = icicle.offsetTop + icicle.offsetHeight + 'px';
                        drop.style.animationDelay = '0s';
                        container.appendChild(drop);
                    }, Math.random() * 5000);
                }
            }
        }
        
        function createPlumBlossoms(container, count) {
            for (let i = 0; i < count; i++) {
                const blossom = document.createElement('div');
                blossom.className = 'plum-blossom interactive-element';
                blossom.style.left = Math.random() * 100 + '%';
                blossom.style.top = Math.random() * 100 + '%';
                blossom.style.animationDelay = Math.random() * 6 + 's';
                container.appendChild(blossom);
            }
        }
        
        function createSpringRain(container, count) {
            for (let i = 0; i < count; i++) {
                const rain = document.createElement('div');
                rain.className = 'rain-drop';
                rain.style.left = Math.random() * 100 + '%';
                rain.style.animationDelay = Math.random() * 2 + 's';
                rain.style.animationDuration = (1.5 + Math.random()) + 's';
                container.appendChild(rain);
            }
            
            // Add sprouts
            for (let i = 0; i < count / 4; i++) {
                const sprout = document.createElement('div');
                sprout.className = 'sprout';
                sprout.style.left = Math.random() * 100 + '%';
                sprout.style.bottom = '0';
                sprout.style.animationDelay = (2 + Math.random() * 3) + 's';
                container.appendChild(sprout);
            }
        }
        
        function createInsects(container, count) {
            for (let i = 0; i < count / 2; i++) {
                const mound = document.createElement('div');
                mound.className = 'soil-mound';
                mound.style.left = Math.random() * 80 + 10 + '%';
                mound.style.bottom = Math.random() * 30 + '%';
                mound.style.animationDelay = Math.random() * 4 + 's';
                container.appendChild(mound);
            }
            
            for (let i = 0; i < count; i++) {
                const insect = document.createElement('div');
                insect.className = 'insect interactive-element';
                insect.style.bottom = Math.random() * 50 + '%';
                insect.style.animationDelay = Math.random() * 6 + 's';
                container.appendChild(insect);
            }
        }
        
        function createSwallows(container, count) {
            for (let i = 0; i < count; i++) {
                const swallow = document.createElement('div');
                swallow.className = 'swallow';
                swallow.style.top = 20 + Math.random() * 60 + '%';
                swallow.style.animationDelay = Math.random() * 8 + 's';
                swallow.style.animationDuration = (6 + Math.random() * 4) + 's';
                container.appendChild(swallow);
            }
        }
        
        function createSakuraAndLeaves(container, count) {
            for (let i = 0; i < count * 0.7; i++) {
                const petal = document.createElement('div');
                petal.className = 'sakura-petal interactive-element';
                petal.style.left = Math.random() * 100 + '%';
                petal.style.animationDelay = Math.random() * 5 + 's';
                petal.style.animationDuration = (4 + Math.random() * 3) + 's';
                container.appendChild(petal);
            }
            
            for (let i = 0; i < count * 0.3; i++) {
                const leaf = document.createElement('div');
                leaf.className = 'young-leaf';
                leaf.style.left = Math.random() * 100 + '%';
                leaf.style.top = Math.random() * 100 + '%';
                leaf.style.animationDelay = Math.random() * 6 + 's';
                container.appendChild(leaf);
            }
        }
        
        function createGrainRain(container, count) {
            for (let i = 0; i < count; i++) {
                const rain = document.createElement('div');
                rain.className = 'grain-rain';
                rain.style.left = Math.random() * 100 + '%';
                rain.style.animationDelay = Math.random() * 1.5 + 's';
                container.appendChild(rain);
                
                // Create ripples where rain hits
                if (Math.random() > 0.8) {
                    setTimeout(() => {
                        const ripple = document.createElement('div');
                        ripple.className = 'ripple';
                        ripple.style.left = rain.style.left;
                        ripple.style.bottom = '10%';
                        ripple.style.animationDelay = '0s';
                        container.appendChild(ripple);
                    }, Math.random() * 3000);
                }
            }
        }
        
        function createFreshGreen(container, count) {
            for (let i = 0; i < count; i++) {
                const leaf = document.createElement('div');
                leaf.className = 'fresh-green';
                leaf.style.left = Math.random() * 100 + '%';
                leaf.style.top = Math.random() * 60 + '%';
                leaf.style.animationDelay = Math.random() * 4 + 's';
                leaf.style.transform = `scale(${0.8 + Math.random() * 0.4})`;
                container.appendChild(leaf);
            }
            
            // Add frogs
            for (let i = 0; i < Math.max(1, count / 5); i++) {
                const frog = document.createElement('div');
                frog.className = 'frog interactive-element';
                frog.style.left = Math.random() * 80 + 10 + '%';
                frog.style.bottom = Math.random() * 30 + '%';
                frog.style.animationDelay = Math.random() * 3 + 's';
                container.appendChild(frog);
            }
        }
        
        function createWheatField(container, count) {
            for (let i = 0; i < count; i++) {
                const wheat = document.createElement('div');
                wheat.className = 'wheat-stalk';
                const grain = document.createElement('div');
                grain.className = 'wheat-grain';
                wheat.appendChild(grain);
                
                wheat.style.left = (i / count) * 100 + '%';
                wheat.style.bottom = Math.random() * 40 + '%';
                wheat.style.animationDelay = (i / count) * 0.5 + 's';
                wheat.style.height = (35 + Math.random() * 15) + 'px';
                container.appendChild(wheat);
            }
        }
        
        function createRiceSeedlings(container, count) {
            // Create water reflection effect
            const water = document.createElement('div');
            water.className = 'water-reflection';
            water.style.bottom = '20%';
            container.appendChild(water);
            
            for (let i = 0; i < count; i++) {
                const seedling = document.createElement('div');
                seedling.className = 'rice-seedling';
                seedling.style.left = (i / count) * 100 + '%';
                seedling.style.bottom = '20%';
                seedling.style.animationDelay = Math.random() * 4 + 's';
                seedling.style.height = (25 + Math.random() * 10) + 'px';
                container.appendChild(seedling);
            }
        }
        
        function createCumulonimbus(container, count) {
            for (let i = 0; i < count; i++) {
                const cloud = document.createElement('div');
                cloud.className = 'cumulonimbus';
                cloud.style.left = 20 + (i * 60 / count) + '%';
                cloud.style.top = 10 + Math.random() * 20 + '%';
                cloud.style.animationDelay = i * 2 + 's';
                cloud.style.transform = `scale(${0.8 + Math.random() * 0.4})`;
                container.appendChild(cloud);
                
                // Add lightning
                if (Math.random() > 0.5) {
                    const lightning = document.createElement('div');
                    lightning.className = 'lightning';
                    lightning.style.left = '50%';
                    lightning.style.top = '80%';
                    lightning.style.animationDelay = (i * 2 + 1) + 's';
                    cloud.appendChild(lightning);
                }
            }
        }
        
        function createWindChimes(container, count) {
            for (let i = 0; i < count; i++) {
                const chime = document.createElement('div');
                chime.className = 'wind-chime interactive-element';
                chime.style.left = (i / count) * 80 + 10 + '%';
                chime.style.top = Math.random() * 30 + '%';
                chime.style.animationDelay = Math.random() * 3 + 's';
                chime.style.animationDuration = (2.5 + Math.random() * 1) + 's';
                container.appendChild(chime);
            }
        }
        
        function createHeatWaves(container, count) {
            for (let i = 0; i < count / 2; i++) {
                const wave = document.createElement('div');
                wave.className = 'heat-wave';
                wave.style.bottom = (i / (count/2)) * 100 + '%';
                wave.style.animationDelay = i * 0.3 + 's';
                container.appendChild(wave);
            }
            
            for (let i = 0; i < count / 2; i++) {
                const cicada = document.createElement('div');
                cicada.className = 'cicada';
                cicada.style.left = Math.random() * 100 + '%';
                cicada.style.top = Math.random() * 50 + '%';
                cicada.style.animationDelay = Math.random() * 1 + 's';
                container.appendChild(cicada);
            }
        }
        
        function createSunsetClouds(container, count) {
            for (let i = 0; i < count; i++) {
                const cloud = document.createElement('div');
                cloud.className = 'sunset-cloud';
                cloud.style.top = 20 + Math.random() * 30 + '%';
                cloud.style.animationDelay = i * 3 + 's';
                cloud.style.animationDuration = (8 + Math.random() * 4) + 's';
                cloud.style.transform = `scale(${0.7 + Math.random() * 0.6})`;
                container.appendChild(cloud);
            }
        }
        
        function createDragonflies(container, count) {
            for (let i = 0; i < count; i++) {
                const dragonfly = document.createElement('div');
                dragonfly.className = 'dragonfly interactive-element';
                dragonfly.style.top = 30 + Math.random() * 40 + '%';
                dragonfly.style.animationDelay = Math.random() * 5 + 's';
                dragonfly.style.animationDuration = (4 + Math.random() * 2) + 's';
                container.appendChild(dragonfly);
            }
        }
        
        function createRiceEars(container, count) {
            for (let i = 0; i < count; i++) {
                const rice = document.createElement('div');
                rice.className = 'rice-ear';
                rice.style.left = (i / count) * 100 + '%';
                rice.style.bottom = Math.random() * 40 + '%';
                rice.style.animationDelay = (i / count) * 0.3 + 's';
                rice.style.height = (40 + Math.random() * 20) + 'px';
                container.appendChild(rice);
            }
        }
        
        function createDewDrops(container, count) {
            for (let i = 0; i < count; i++) {
                const dew = document.createElement('div');
                dew.className = 'dew-drop interactive-element';
                dew.style.left = Math.random() * 100 + '%';
                dew.style.top = 40 + Math.random() * 40 + '%';
                dew.style.animationDelay = Math.random() * 3 + 's';
                dew.style.transform = `scale(${0.6 + Math.random() * 0.8})`;
                container.appendChild(dew);
            }
        }
        
        function createRedSpiderLilies(container, count) {
            for (let i = 0; i < count; i++) {
                const lily = document.createElement('div');
                lily.className = 'red-spider-lily';
                lily.style.left = Math.random() * 80 + 10 + '%';
                lily.style.bottom = Math.random() * 30 + '%';
                lily.style.animationDelay = Math.random() * 6 + 's';
                container.appendChild(lily);
            }
        }
        
        function createWildGeese(container, count) {
            for (let i = 0; i < count; i++) {
                const geese = document.createElement('div');
                geese.className = 'wild-geese';
                geese.style.top = 10 + i * 20 + '%';
                geese.style.animationDelay = i * 4 + 's';
                geese.style.animationDuration = (10 + Math.random() * 4) + 's';
                container.appendChild(geese);
            }
        }
        
        function createAutumnLeaves(container, count) {
            for (let i = 0; i < count; i++) {
                const leaf = document.createElement('div');
                leaf.className = 'autumn-leaf interactive-element';
                leaf.style.left = Math.random() * 100 + '%';
                leaf.style.animationDelay = Math.random() * 5 + 's';
                leaf.style.animationDuration = (4 + Math.random() * 3) + 's';
                leaf.style.transform = `scale(${0.7 + Math.random() * 0.6}) rotate(${Math.random() * 360}deg)`;
                container.appendChild(leaf);
            }
        }
        
        function createFrost(container, count) {
            for (let i = 0; i < count; i++) {
                const frost = document.createElement('div');
                frost.className = 'frost';
                frost.style.left = Math.random() * 100 + '%';
                frost.style.top = Math.random() * 100 + '%';
                frost.style.animationDelay = Math.random() * 4 + 's';
                frost.style.transform = `scale(${0.5 + Math.random() * 1})`;
                container.appendChild(frost);
            }
        }
        
        function createBareBranches(container, count) {
            for (let i = 0; i < count; i++) {
                const branch = document.createElement('div');
                branch.className = 'bare-branch';
                branch.style.left = Math.random() * 80 + 10 + '%';
                branch.style.top = Math.random() * 50 + '%';
                branch.style.animationDelay = Math.random() * 8 + 's';
                branch.style.transform = `scale(${0.8 + Math.random() * 0.4})`;
                container.appendChild(branch);
            }
        }
        
        function createLightSnow(container, count) {
            for (let i = 0; i < count; i++) {
                const snow = document.createElement('div');
                snow.className = 'light-snow interactive-element';
                snow.style.left = Math.random() * 100 + '%';
                snow.style.animationDelay = Math.random() * 6 + 's';
                snow.style.animationDuration = (5 + Math.random() * 3) + 's';
                container.appendChild(snow);
            }
        }
        
        function createHeavySnow(container, count) {
            for (let i = 0; i < count; i++) {
                const snow = document.createElement('div');
                snow.className = 'heavy-snow interactive-element';
                snow.style.left = Math.random() * 100 + '%';
                snow.style.animationDelay = Math.random() * 4 + 's';
                snow.style.animationDuration = (3 + Math.random() * 2) + 's';
                snow.style.transform = `scale(${0.8 + Math.random() * 0.4})`;
                container.appendChild(snow);
            }
        }
        
        function createCandleFlame(container, count) {
            const flame = document.createElement('div');
            flame.className = 'candle-flame';
            flame.style.left = '50%';
            flame.style.bottom = '30%';
            flame.style.transform = 'translateX(-50%)';
            container.appendChild(flame);
        }
        
        function createYuzu(container, count) {
            for (let i = 0; i < count; i++) {
                const yuzu = document.createElement('div');
                yuzu.className = 'yuzu interactive-element';
                yuzu.style.left = 30 + Math.random() * 40 + '%';
                yuzu.style.bottom = 20 + Math.random() * 20 + '%';
                yuzu.style.animationDelay = Math.random() * 5 + 's';
                container.appendChild(yuzu);
            }
        }
        
        function setupInteractiveElements(container) {
            const interactiveEls = container.querySelectorAll('.interactive-element');
            
            interactiveEls.forEach(el => {
                el.addEventListener('click', function(e) {
                    e.stopPropagation();
                    this.style.animation = 'none';
                    setTimeout(() => {
                        this.style.animation = '';
                        this.style.animationPlayState = 'running';
                    }, 100);
                    
                    // Create a visual effect on click
                    const effect = document.createElement('div');
                    effect.style.position = 'absolute';
                    effect.style.width = '50px';
                    effect.style.height = '50px';
                    effect.style.borderRadius = '50%';
                    effect.style.background = 'rgba(255,255,255,0.5)';
                    effect.style.left = e.offsetX - 25 + 'px';
                    effect.style.top = e.offsetY - 25 + 'px';
                    effect.style.pointerEvents = 'none';
                    effect.style.animation = 'ripple 0.6s ease-out';
                    this.appendChild(effect);
                    
                    setTimeout(() => effect.remove(), 600);
                });
            });
        }

        function createRipple(e) {
            const button = e.currentTarget;
            if (button.disabled) return;
            const ripple = document.createElement('span');
            const rect = button.getBoundingClientRect();
            const size = Math.max(rect.width, rect.height);
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const x = clientX - rect.left - size / 2;
            const y = clientY - rect.top - size / 2;
            ripple.style.width = ripple.style.height = size + 'px';
            ripple.style.left = x + 'px';
            ripple.style.top = y + 'px';
            ripple.classList.add('ripple');
            const existingRipple = button.querySelector('.ripple');
            if (existingRipple) { existingRipple.remove(); }
            button.appendChild(ripple);
            setTimeout(() => ripple.remove(), 1000);
        }

        const app = {
            tasks: [],
            deadlineTasks: [],
            inboxItems: [],
            selectedDate: new Date(),
            taskType: 'normal',
            totalPoints: 0,
            dailyPointHistory: {},
            dailyReflections: {},
            openaiApiKey: null,

            init() {
                this.loadData();
                this.bindEvents();
                this.updateSekki();
                this.updateTodayDisplay();
            },

            updateSekki() { /* Same as before */
                const now = new Date();
                const year = now.getFullYear();
                const currentYearSekki = sekkiData[year] || [];
                const nextYearSekki = sekkiData[year + 1] || [];
                const allSekki = [...currentYearSekki, ...nextYearSekki];
                let currentSekki = null;
                let nextSekki = null;
                for (let i = 0; i < allSekki.length; i++) {
                    if (now >= allSekki[i].date) { currentSekki = allSekki[i]; } 
                    else { nextSekki = allSekki[i]; break; }
                }
                if (!currentSekki && allSekki.length > 0) {
                    currentSekki = allSekki.find(s => now < s.date) || allSekki[allSekki.length -1]; 
                    if (!currentSekki && sekkiData[year-1] && sekkiData[year-1].length > 0) { 
                        currentSekki = sekkiData[year-1][sekkiData[year-1].length -1];
                    }
                }
                if (currentSekki) {
                    document.getElementById('currentSekki').textContent = currentSekki.name;
                    const dateStr = currentSekki.date.toLocaleDateString('ja-JP', { month: 'long', day: 'numeric' });
                    document.getElementById('sekkiDate').textContent = `${dateStr}より`;
                    const bg = document.getElementById('backgroundSeason');
                    bg.className = bg.className.replace(/bg-[\u4E00-\u9FA5]+/g, '');
                    bg.classList.add(`bg-${currentSekki.name}`);
                    createSeasonalAnimation(currentSekki.name); 
                    this.showSekkiDetail(currentSekki);
                }
                if (nextSekki) {
                    const daysUntil = Math.ceil((nextSekki.date - now) / (1000 * 60 * 60 * 24));
                    document.getElementById('nextSekkiInfo').textContent = `次は「${nextSekki.name}」 あと${daysUntil}日`;
                } else {
                     document.getElementById('nextSekkiInfo').textContent = `次の節気情報は翌年になります`;
                }
                this.updateYearSekkiList();
                this.render();
                this.updateTodayDisplay();
             },
            
            updateYearSekkiList() { /* Same as before */
                const year = this.selectedDate.getFullYear(); 
                const yearSekki = sekkiData[year] || [];
                const listEl = document.getElementById('yearSekkiList');
                listEl.innerHTML = '';
                yearSekki.forEach(sekki => {
                    const itemEl = document.createElement('div');
                    const isPast = new Date() > sekki.date && !this.isCurrentSekki(sekki, this.selectedDate); 
                    const isCurrentlyDisplayedSekki = this.isCurrentSekki(sekki, this.selectedDate); 
                    itemEl.className = `p-1.5 sm:p-2 rounded text-center transition-all cursor-pointer ${
                        isCurrentlyDisplayedSekki ? 'bg-gray-800 text-white' : 
                        isPast ? 'text-gray-400' : 'text-gray-700 hover:bg-gray-100'
                    }`;
                    itemEl.innerHTML = `
                        <div class="font-medium text-xs sm:text-sm">${sekki.name}</div>
                        <div class="text-xs ${isCurrentlyDisplayedSekki ? 'text-gray-300' : 'text-gray-500'}">
                            ${sekki.date.getMonth() + 1}/${sekki.date.getDate()}
                        </div>`;
                    itemEl.addEventListener('click', () => {
                        this.showSekkiDetail(sekki); 
                        this.updateYearSekkiList(); 
                    });
                    listEl.appendChild(itemEl);
                });},
            
            showSekkiDetail(sekki) { /* Same as before */
                document.getElementById('sekkiDetailName').textContent = sekki.name;
                document.getElementById('sekkiDetailDate').textContent = sekki.date.toLocaleDateString('ja-JP', { 
                    year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric'
                });
                document.getElementById('sekkiDescription').textContent = sekki.description;
                const bg = document.getElementById('backgroundSeason');
                bg.className = bg.className.replace(/bg-[\u4E00-\u9FA5]+/g, '');
                bg.classList.add(`bg-${sekki.name}`);
                createSeasonalAnimation(sekki.name);},
            
            isCurrentSekki(sekkiToCheck, referenceDate) { /* Same as before */
                const year = referenceDate.getFullYear();
                const allSekkiForYear = sekkiData[year] || [];
                const allSekkiForPrevYear = sekkiData[year-1] || [];
                const relevantSekki = [...allSekkiForPrevYear.slice(-1), ...allSekkiForYear];
                for (let i = 0; i < relevantSekki.length; i++) {
                    const currentS = relevantSekki[i];
                    const nextS = relevantSekki[i + 1];
                    if (referenceDate >= currentS.date) {
                        if (nextS && referenceDate < nextS.date) {
                            return sekkiToCheck.name === currentS.name && sekkiToCheck.date.getTime() === currentS.date.getTime();
                        } else if (!nextS) { 
                            return sekkiToCheck.name === currentS.name && sekkiToCheck.date.getTime() === currentS.date.getTime();
                        }
                    }
                }
                return false;},
            
            updateCalendarSekkiInfo() { /* Same as before */
                const dateInput = document.getElementById('dateInput');
                if (!dateInput.value) return; 
                const selectedDate = new Date(dateInput.value);
                if (isNaN(selectedDate.getTime())) return; 
                const year = selectedDate.getFullYear();
                const sekkiList = [...(sekkiData[year - 1] || []), ...(sekkiData[year] || []), ...(sekkiData[year + 1] || [])].filter(s => s); 
                if (sekkiList.length === 0) {
                     document.getElementById('calendarSekkiInfo').classList.add('hidden');
                     return;
                }
                let currentSekkiForDate = null;
                for (let i = 0; i < sekkiList.length; i++) {
                    if (selectedDate >= sekkiList[i].date) {
                        currentSekkiForDate = sekkiList[i];
                    } else {
                        if (!currentSekkiForDate) currentSekkiForDate = sekkiList[i]; 
                        break;
                    }
                }
                const infoEl = document.getElementById('calendarSekkiInfo');
                if (currentSekkiForDate) {
                    let message = `選択日は「${currentSekkiForDate.name}」の期間です。`;
                    if (selectedDate.toDateString() === currentSekkiForDate.date.toDateString()){
                        message = `この日は「${currentSekkiForDate.name}」です。`;
                    } else {
                        const currentIndexInYear = (sekkiData[currentSekkiForDate.date.getFullYear()] || []).findIndex(s => s.name === currentSekkiForDate.name);
                        const yearSekki = sekkiData[currentSekkiForDate.date.getFullYear()] || [];
                        if (selectedDate < currentSekkiForDate.date && currentIndexInYear > 0) {
                            const prevSekki = yearSekki[currentIndexInYear -1];
                            message = `「${prevSekki.name}」の期間、次の節気は「${currentSekkiForDate.name}」です。`;
                        } else if (selectedDate > currentSekkiForDate.date) {
                            const nextSekkiInList = yearSekki[currentIndexInYear + 1];
                            if (nextSekkiInList && selectedDate >= nextSekkiInList.date) {
                                message = `選択日は「${nextSekkiInList.name}」の期間です。`;
                            } else {
                                message = `「${currentSekkiForDate.name}」の期間です。`;
                            }
                        }
                    }
                    infoEl.textContent = message;
                    infoEl.classList.remove('hidden');
                } else {
                    infoEl.classList.add('hidden');
                }
            },

            loadData() { /* Same as before */
                const saved = localStorage.getItem('focusTaskData');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.tasks = (data.tasks || []).map(t => ({ ...t, createdAt: new Date(t.createdAt), completedAt: t.completedAt ? new Date(t.completedAt) : null, scheduledFor: new Date(t.scheduledFor), points: t.points || 0 }));
                    this.deadlineTasks = (data.deadlineTasks || []).map(t => ({ ...t, deadline: new Date(t.deadline), createdAt: new Date(t.createdAt), completedAt: t.completedAt ? new Date(t.completedAt) : null }));
                    this.inboxItems = data.inboxItems || [];
                    this.totalPoints = data.totalPoints || 0;
                    this.dailyPointHistory = data.dailyPointHistory || {};
                    this.dailyReflections = data.dailyReflections || {};
                    this.openaiApiKey = data.openaiApiKey || null;
                }},

            saveData() { /* Same as before */
                localStorage.setItem('focusTaskData', JSON.stringify({ 
                    tasks: this.tasks, 
                    deadlineTasks: this.deadlineTasks, 
                    inboxItems: this.inboxItems, 
                    totalPoints: this.totalPoints, 
                    dailyPointHistory: this.dailyPointHistory,
                    dailyReflections: this.dailyReflections,
                    openaiApiKey: this.openaiApiKey
                }));},

            bindEvents() { 
                document.getElementById('prevDay').addEventListener('click', () => this.navigateDate(-1));
                document.getElementById('nextDay').addEventListener('click', () => this.navigateDate(1));
                document.getElementById('todayButton').addEventListener('click', () => this.goToToday());
                // Calendar is always visible, no toggle needed
                const dateInputElement = document.getElementById('dateInput');
                dateInputElement.addEventListener('change', (e) => this.selectDate(e.target.value));
                dateInputElement.addEventListener('input', () => this.updateCalendarSekkiInfo()); 
                document.getElementById('normalType').addEventListener('click', () => this.setTaskType('normal'));
                document.getElementById('urgentType').addEventListener('click', () => this.setTaskType('urgent'));
                document.getElementById('addTask').addEventListener('click', () => this.addTask());
                document.getElementById('taskInput').addEventListener('keypress', (e) => { 
                    if (e.key === 'Enter') {
                        if (this.taskType === 'urgent' && this.selectedPoints === 0) {
                            // 目標タスクでポイント未選択の場合は何もしない
                            return;
                        }
                        this.addTask();
                    }
                });
                document.querySelectorAll('.point-select-button').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const points = parseInt(e.currentTarget.dataset.points);
                        this.selectPoints(points);
                        // ポイント選択後、自動的にタスクを追加
                        setTimeout(() => this.addTask(), 200);
                    });
                });
                document.getElementById('deadlineToggle').addEventListener('click', () => this.toggleDeadlineForm());
                document.getElementById('addDeadline').addEventListener('click', () => this.addDeadlineTask());
                document.getElementById('cancelDeadline').addEventListener('click', () => this.toggleDeadlineForm(false)); 
                document.getElementById('inboxToggle').addEventListener('click', () => this.toggleInbox());
                document.getElementById('addInbox').addEventListener('click', () => this.addInboxItem());
                document.getElementById('inboxInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') this.addInboxItem(); });
                document.getElementById('statsToggle').addEventListener('click', () => this.toggleStats());
                document.getElementById('resetStats').addEventListener('click', () => this.resetStats());
                document.getElementById('reflectionToggle').addEventListener('click', () => this.toggleReflection());
                document.getElementById('saveReflection').addEventListener('click', () => this.saveReflection());
                document.getElementById('cancelReflection').addEventListener('click', () => this.toggleReflection(false));
                document.getElementById('reflectionInput').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.ctrlKey) this.saveReflection();
                });
                document.getElementById('aiSettingsToggle').addEventListener('click', () => this.toggleApiKeyForm());
                document.getElementById('saveApiKey').addEventListener('click', () => this.saveApiKey());
                document.getElementById('cancelApiKey').addEventListener('click', () => this.toggleApiKeyForm(false));
                document.querySelectorAll('.ai-period-button').forEach(btn => {
                    btn.addEventListener('click', (e) => this.generateAIComment(e.target.dataset.period));
                });

                // --- NEW: スワイプによる日付移動機能 ---
                const swipeArea = document.body;
                let touchStartX = 0;
                let touchStartY = 0;
                let isSwipeActive = false; // スワイプ操作中かどうかのフラグ

                swipeArea.addEventListener('touchstart', (e) => {
                    // ボタンや入力、特定の操作エリアではスワイプを開始しない
                    if (e.target.closest('button, input, a, .sekki-grid')) {
                        isSwipeActive = false;
                        return;
                    }
                    isSwipeActive = true;
                    touchStartX = e.changedTouches[0].screenX;
                    touchStartY = e.changedTouches[0].screenY;
                }, { passive: true });

                swipeArea.addEventListener('touchend', (e) => {
                    if (!isSwipeActive) return;
                    isSwipeActive = false; // フラグをリセット

                    const touchEndX = e.changedTouches[0].screenX;
                    const touchEndY = e.changedTouches[0].screenY;
                    this.handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
                }, { passive: true });
            },
            
            // --- NEW: スワイプ操作を処理するメソッド ---
            handleSwipe(startX, startY, endX, endY) {
                const thresholdX = 50;  // 横スワイプとして認識する最小距離
                const restraintY = 100; // 横スワイプ中に許容される縦の最大移動距離

                const diffX = endX - startX;
                const diffY = endY - startY;

                // 横方向の移動がしきい値を超え、縦方向の移動が抑制範囲内かをチェック
                if (Math.abs(diffX) > thresholdX && Math.abs(diffY) < restraintY) {
                    if (diffX > 0) {
                        this.navigateDate(-1); // 右スワイプで前の日へ
                    } else {
                        this.navigateDate(1);  // 左スワイプで次の日へ
                    }
                }
            },

            navigateDate(days) { /* Same as before */
                const newDate = new Date(this.selectedDate);
                newDate.setDate(newDate.getDate() + days);
                this.selectedDate = newDate;
                this.updateSekkiForSelectedDate();
                this.render();},

            goToToday() { /* Same as before */
                this.selectedDate = new Date();
                this.updateSekkiForSelectedDate();
                this.render();},

            selectDate(dateStr) { /* Same as before */
                const newDate = new Date(dateStr);
                if (!isNaN(newDate.getTime())) {
                    this.selectedDate = newDate;
                    // Calendar always visible, no need to hide
                    this.updateCalendarSekkiInfo(); 
                    this.updateSekkiForSelectedDate(); 
                    this.render();
                } else {
                    this.showError("無効な日付形式です。");
                }},
            updateSekkiForSelectedDate() { /* Same as before */
                const year = this.selectedDate.getFullYear();
                const allSekki = [...(sekkiData[year] || []), ...(sekkiData[year + 1] || [])];
                let currentSekkiForDisplay = null;
                let nextSekkiForDisplay = null;
                for (let i = 0; i < allSekki.length; i++) {
                    if (this.selectedDate >= allSekki[i].date) { currentSekkiForDisplay = allSekki[i];} 
                    else { nextSekkiForDisplay = allSekki[i]; break; }
                }
                if (!currentSekkiForDisplay && allSekki.length > 0) {
                    const prevYearSekki = sekkiData[year - 1] || [];
                    if (prevYearSekki.length > 0) { currentSekkiForDisplay = prevYearSekki[prevYearSekki.length -1]; } 
                    else { currentSekkiForDisplay = allSekki[0]; }
                }
                if (currentSekkiForDisplay) {
                    document.getElementById('currentSekki').textContent = currentSekkiForDisplay.name;
                    const dateStr = currentSekkiForDisplay.date.toLocaleDateString('ja-JP', { month: 'long', day: 'numeric' });
                    document.getElementById('sekkiDate').textContent = `${dateStr}より`;
                    const bg = document.getElementById('backgroundSeason');
                    bg.className = bg.className.replace(/bg-[\u4E00-\u9FA5]+/g, '');
                    bg.classList.add(`bg-${currentSekkiForDisplay.name}`);
                    createSeasonalAnimation(currentSekkiForDisplay.name);
                    this.showSekkiDetail(currentSekkiForDisplay);
                }
                if (nextSekkiForDisplay) {
                    const daysUntil = Math.ceil((nextSekkiForDisplay.date - this.selectedDate) / (1000 * 60 * 60 * 24));
                    document.getElementById('nextSekkiInfo').textContent = `次は「${nextSekkiForDisplay.name}」 あと${daysUntil > 0 ? daysUntil : 0}日`;
                } else {
                     document.getElementById('nextSekkiInfo').textContent = `次の節気情報は翌年になります`;
                }
                this.updateYearSekkiList();},

            toggleCalendar() { /* Same as before */
                const dateInputEl = document.getElementById('dateInput');
                // Always visible, so just update the date and focus
                dateInputEl.value = this.selectedDate.toISOString().split('T')[0];
                this.updateCalendarSekkiInfo(); 
                dateInputEl.focus();
            },

            setTaskType(type) { /* Same as before */
                this.taskType = type;
                const normalButton = document.getElementById('normalType');
                const urgentButton = document.getElementById('urgentType');
                const pointSelector = document.getElementById('pointSelector');
                const addButton = document.getElementById('addTask');
                
                normalButton.className = `flex-1 px-4 py-2 rounded-full font-medium transition-all button-large ${ type === 'normal' ? 'bg-gray-800 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200' }`;
                urgentButton.className = `flex-1 px-4 py-2 rounded-full font-medium transition-all button-large ${ type === 'urgent' ? 'bg-gray-800 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200' }`;
                
                if (type === 'urgent') {
                    pointSelector.classList.remove('hidden');
                    addButton.classList.add('hidden');
                    this.selectedPoints = 0;
                    document.querySelectorAll('.point-select-button').forEach(btn => {
                        btn.classList.remove('border-gray-800', 'bg-gray-100');
                        btn.classList.add('border-gray-300');
                    });
                } else {
                    pointSelector.classList.add('hidden');
                    addButton.classList.remove('hidden');
                    this.selectedPoints = 0;
                }},

            selectedPoints: 0,
            
            selectPoints(points) {
                this.selectedPoints = points;
                document.querySelectorAll('.point-select-button').forEach(btn => {
                    const btnPoints = parseInt(btn.dataset.points);
                    if (btnPoints === points) {
                        btn.classList.add('border-gray-800', 'bg-gray-100');
                        btn.classList.remove('border-gray-300');
                    } else {
                        btn.classList.remove('border-gray-800', 'bg-gray-100');
                        btn.classList.add('border-gray-300');
                    }
                });
            },
            
            addTask() { /* Same as before */
                const input = document.getElementById('taskInput');
                const text = input.value.trim();
                if (!text) { this.showError('予定を入力してください'); return; }
                
                if (this.taskType === 'urgent' && this.selectedPoints === 0) {
                    this.showError('目標タスクにはポイントを設定してください');
                    return;
                }
                
                const todayTasks = this.getTodayTasks();
                const normalCount = todayTasks.filter(t => t.type === 'normal' && !t.isCompleted).length; 
                const urgentCount = todayTasks.filter(t => t.type === 'urgent' && !t.isCompleted).length; 
                if (this.taskType === 'normal' && normalCount >= 3) { this.showError('通常タスクは3件までです（未完了）'); return; }
                if (this.taskType === 'urgent' && urgentCount >= 3) { this.showError('目標タスクは3件までです（未完了）'); return; }
                const newTask = { id: Date.now().toString(), text: text, type: this.taskType, points: this.taskType === 'urgent' ? this.selectedPoints : 0, createdAt: new Date(), completedAt: null, isCompleted: false, scheduledFor: new Date(this.selectedDate) };
                this.tasks.push(newTask);
                input.value = '';
                
                // リセット
                this.selectedPoints = 0;
                document.querySelectorAll('.point-select-button').forEach(btn => {
                    btn.classList.remove('border-gray-800', 'bg-gray-100');
                    btn.classList.add('border-gray-300');
                });
                
                this.saveData();
                this.render();},

            toggleTask(taskId) { /* Same as before */
                const task = this.tasks.find(t => t.id === taskId);
                if (!task) return;
                if (!task.isCompleted) { 
                    this.showCelebration();
                    if (task.type === 'urgent' && task.points > 0) {
                        this.totalPoints += task.points;
                        const today = new Date().toDateString();
                        if (!this.dailyPointHistory[today]) {
                            this.dailyPointHistory[today] = 0;
                        }
                        this.dailyPointHistory[today] += task.points;
                    }
                } else {
                    if (task.type === 'urgent' && task.points > 0) {
                        this.totalPoints -= task.points;
                        const today = new Date().toDateString();
                        if (this.dailyPointHistory[today]) {
                            this.dailyPointHistory[today] -= task.points;
                        }
                    }
                }
                task.isCompleted = !task.isCompleted;
                task.completedAt = task.isCompleted ? new Date() : null;
                this.saveData();
                this.render();},

            postponeTask(taskId) { /* Same as before */
                const task = this.tasks.find(t => t.id === taskId);
                if (!task) return;
                const tomorrow = new Date(this.selectedDate);
                tomorrow.setDate(tomorrow.getDate() + 1);
                const tomorrowTasks = this.tasks.filter(t => new Date(t.scheduledFor).toDateString() === tomorrow.toDateString() && !t.isCompleted );
                const normalCount = tomorrowTasks.filter(t => t.type === 'normal').length;
                const urgentCount = tomorrowTasks.filter(t => t.type === 'urgent').length;
                if (task.type === 'normal' && normalCount >= 3) { this.showError('翌日の通常タスクは既に3件です（未完了）'); return; }
                if (task.type === 'urgent' && urgentCount >= 3) { this.showError('翌日の目標タスクは既に3件です（未完了）'); return; }
                task.scheduledFor = tomorrow;
                this.showPostponeEffect();
                setTimeout(() => { this.saveData(); this.render(); }, 600);},

            deleteTask(taskId) { /* Same as before */
                this.tasks = this.tasks.filter(t => t.id !== taskId);
                this.saveData();
                this.render();},

            toggleDeadlineForm(forceHide = null) { /* Same as before */
                const form = document.getElementById('deadlineForm');
                const activeCount = this.deadlineTasks.filter(t => !t.isCompleted).length;
                if (forceHide === false) { form.classList.add('hidden'); return; }
                if (forceHide === true) { if (activeCount < 3) form.classList.remove('hidden'); else this.showError('期限付きタスクは3件までです'); return; }
                if (form.classList.contains('hidden')) { 
                    if (activeCount >= 3) { this.showError('期限付きタスクは3件までです'); return; }
                    form.classList.remove('hidden');
                    document.getElementById('deadlineDate').min = new Date().toISOString().split('T')[0];
                    document.getElementById('deadlineText').focus();
                } else { 
                    form.classList.add('hidden');
                }},

            addDeadlineTask() { /* Same as before */
                const textEl = document.getElementById('deadlineText');
                const dateEl = document.getElementById('deadlineDate');
                const text = textEl.value.trim();
                const date = dateEl.value;
                if (!text || !date) { this.showError('内容と期限を入力してください'); return; }
                const activeCount = this.deadlineTasks.filter(t => !t.isCompleted).length;
                if (activeCount >= 3) { this.showError('期限付きタスクは3件までです'); return; }
                const newTask = { id: Date.now().toString(), text: text, deadline: new Date(date + "T23:59:59"), createdAt: new Date(), isCompleted: false, completedAt: null };
                this.deadlineTasks.push(newTask);
                textEl.value = ''; dateEl.value = '';
                this.toggleDeadlineForm(false); 
                this.saveData(); this.render();},

            toggleDeadlineTask(taskId) { /* Same as before */
                const task = this.deadlineTasks.find(t => t.id === taskId);
                if (!task) return;
                if (!task.isCompleted) { this.showCelebration(); }
                task.isCompleted = !task.isCompleted;
                task.completedAt = task.isCompleted ? new Date() : null;
                this.saveData();
                this.render();},
            
            // --- NEW: Delete Deadline Task ---
            deleteDeadlineTask(taskId) {
                this.deadlineTasks = this.deadlineTasks.filter(t => t.id !== taskId);
                this.saveData();
                this.render();
            },

            toggleInbox() { /* Same as before */
                const inboxSection = document.getElementById('inboxSection');
                inboxSection.classList.toggle('hidden');
                if(!inboxSection.classList.contains('hidden')) { document.getElementById('inboxInput').focus(); }},

            addInboxItem() { /* Same as before */
                const input = document.getElementById('inboxInput');
                const text = input.value.trim();
                if (!text) return;
                this.inboxItems.push({ id: Date.now().toString(), text: text });
                input.value = ''; this.saveData(); this.render(); },
            
            deleteInboxItem(itemId) { /* Same as before */
                this.inboxItems = this.inboxItems.filter(item => item.id !== itemId);
                this.saveData(); this.render();},

            getTodayTasks() { /* Same as before */
                const dateStr = this.selectedDate.toDateString();
                return this.tasks.filter(t => new Date(t.scheduledFor).toDateString() === dateStr);},

            getDaysUntilDeadline(deadline) { /* Same as before */
                const today = new Date(); today.setHours(0, 0, 0, 0); 
                const deadlineDate = new Date(deadline); deadlineDate.setHours(0, 0, 0, 0);
                const diffTime = deadlineDate - today;
                return Math.ceil(diffTime / (1000 * 60 * 60 * 24));},

            formatDate(date) { /* Same as before */
                const today = new Date(); today.setHours(0,0,0,0);
                const compDate = new Date(date); compDate.setHours(0,0,0,0);
                if (compDate.toDateString() === today.toDateString()) return '本日';
                const tomorrow = new Date(today); tomorrow.setDate(today.getDate() + 1);
                if (compDate.toDateString() === tomorrow.toDateString()) return '明日';
                const yesterday = new Date(today); yesterday.setDate(today.getDate() - 1);
                if (compDate.toDateString() === yesterday.toDateString()) return '昨日';
                return `${compDate.getMonth() + 1}月${compDate.getDate()}日`;
            },
            
            formatDateDetails(date) {
                const weekdays = ['日曜日', '月曜日', '火曜日', '水曜日', '木曜日', '金曜日', '土曜日'];
                const today = new Date();
                today.setHours(0,0,0,0);
                const compDate = new Date(date);
                compDate.setHours(0,0,0,0);
                
                return {
                    year: compDate.getFullYear() + '年',
                    date: this.formatDate(date),
                    day: weekdays[compDate.getDay()],
                    isToday: compDate.toDateString() === today.toDateString()
                };
            },
            
            updateTodayDisplay() {
                const today = new Date();
                const weekdays = ['日曜日', '月曜日', '火曜日', '水曜日', '木曜日', '金曜日', '土曜日'];
                document.getElementById('todayDateYear').textContent = today.getFullYear() + '年';
                document.getElementById('todayDateFull').textContent = (today.getMonth() + 1) + '月' + today.getDate() + '日';
                document.getElementById('todayDateDay').textContent = weekdays[today.getDay()];
            },

            showError(message) { /* Same as before */
                const elem = document.getElementById('errorMessage');
                elem.textContent = message; elem.classList.remove('hidden');
                setTimeout(() => elem.classList.add('hidden'), 3000);},

            showCelebration() { /* Same as before */
                const elem = document.getElementById('celebration');
                elem.classList.remove('hidden');
                setTimeout(() => elem.classList.add('hidden'), 1500);},

            showPostponeEffect() { /* Same as before */
                const elem = document.getElementById('postponeEffect');
                elem.classList.remove('hidden');
                setTimeout(() => elem.classList.add('hidden'), 1500);},

            toggleStats() {
                const statsSection = document.getElementById('statsSection');
                statsSection.classList.toggle('hidden');
                if (!statsSection.classList.contains('hidden')) {
                    this.renderWeeklyStats();
                }
            },
            
            renderWeeklyStats() {
                const weeklyStatsEl = document.getElementById('weeklyStats');
                weeklyStatsEl.innerHTML = '';
                
                const today = new Date();
                for (let i = 6; i >= 0; i--) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    const dateStr = date.toDateString();
                    const points = this.dailyPointHistory[dateStr] || 0;
                    const dayName = i === 0 ? '今日' : i === 1 ? '昨日' : date.toLocaleDateString('ja-JP', { month: 'numeric', day: 'numeric' });
                    
                    const dayEl = document.createElement('div');
                    dayEl.className = 'flex items-center justify-between p-2 rounded-lg ' + (i === 0 ? 'bg-amber-50' : 'bg-gray-50');
                    dayEl.innerHTML = `
                        <span class="text-sm text-gray-700">${dayName}</span>
                        <div class="flex items-center gap-2">
                            <div class="h-2 bg-gray-200 rounded-full" style="width: 100px;">
                                <div class="h-full bg-amber-500 rounded-full transition-all" style="width: ${Math.min(points * 10, 100)}%;"></div>
                            </div>
                            <span class="text-sm font-medium text-gray-700 w-12 text-right">${points}pt</span>
                        </div>
                    `;
                    weeklyStatsEl.appendChild(dayEl);
                }
            },
            
            resetStats() {
                if (confirm('すべてのポイント統計をリセットしますか？')) {
                    this.totalPoints = 0;
                    this.dailyPointHistory = {};
                    this.saveData();
                    this.render();
                    this.renderWeeklyStats();
                }
            },
            
            toggleReflection(forceHide = null) {
                const form = document.getElementById('reflectionForm');
                const toggle = document.getElementById('reflectionToggle');
                
                if (forceHide === false) {
                    form.classList.add('hidden');
                    return;
                }
                
                form.classList.toggle('hidden');
                if (!form.classList.contains('hidden')) {
                    const dateStr = this.selectedDate.toDateString();
                    const reflection = this.dailyReflections[dateStr] || '';
                    document.getElementById('reflectionInput').value = reflection;
                    document.getElementById('reflectionInput').focus();
                }
            },
            
            saveReflection() {
                const input = document.getElementById('reflectionInput');
                const text = input.value.trim();
                const dateStr = this.selectedDate.toDateString();
                
                if (text) {
                    this.dailyReflections[dateStr] = text;
                } else {
                    delete this.dailyReflections[dateStr];
                }
                
                this.saveData();
                this.toggleReflection(false);
                this.render();
            },
            
            toggleApiKeyForm(forceHide = null) {
                const form = document.getElementById('apiKeyForm');
                
                if (forceHide === false) {
                    form.classList.add('hidden');
                    return;
                }
                
                form.classList.toggle('hidden');
                if (!form.classList.contains('hidden')) {
                    document.getElementById('apiKeyInput').value = this.openaiApiKey || '';
                    document.getElementById('apiKeyInput').focus();
                }
            },
            
            saveApiKey() {
                const input = document.getElementById('apiKeyInput');
                const key = input.value.trim();
                
                if (key) {
                    this.openaiApiKey = key;
                } else {
                    this.openaiApiKey = null;
                }
                
                this.saveData();
                this.toggleApiKeyForm(false);
                this.render();
            },
            
            async generateAIComment(period) {
                if (!this.openaiApiKey) {
                    this.showError('APIキーを設定してください');
                    return;
                }
                
                const periodNames = {
                    daily: 'デイリー',
                    weekly: '週間',
                    sekki: '節気間',
                    monthly: '月間',
                    quarterly: '3ヶ月'
                };
                
                if (!confirm(`${periodNames[period]}のAIコメントを生成しますか？`)) {
                    return;
                }
                
                const loading = document.getElementById('aiCommentLoading');
                const content = document.getElementById('aiCommentContent');
                const noApiKey = document.getElementById('noApiKey');
                
                loading.classList.remove('hidden');
                content.classList.add('hidden');
                noApiKey.classList.add('hidden');
                
                try {
                    const prompt = this.buildAIPrompt(period);
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.openaiApiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-3.5-turbo',
                            messages: [{
                                role: 'system',
                                content: 'You are a supportive coach for someone with ADHD tendencies. Provide encouraging, practical advice while being understanding of ADHD challenges. Write in Japanese. IMPORTANT: Always complete your sentences and thoughts. Never cut off mid-sentence. Ensure your response is a complete, coherent message.'
                            }, {
                                role: 'user',
                                content: prompt
                            }],
                            temperature: 0.7,
                            max_tokens: period === 'quarterly' ? 3000 : period === 'monthly' ? 1500 : period === 'sekki' ? 1200 : period === 'weekly' ? 900 : 600
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('APIリクエストが失敗しました');
                    }
                    
                    const data = await response.json();
                    const message = data.choices[0].message.content;
                    
                    content.textContent = message;
                    content.classList.remove('hidden');
                    loading.classList.add('hidden');
                    
                    // ボタンのハイライト
                    document.querySelectorAll('.ai-period-button').forEach(btn => {
                        if (btn.dataset.period === period) {
                            btn.classList.add('bg-gray-800', 'text-white');
                            btn.classList.remove('bg-gray-200', 'text-gray-700');
                        } else {
                            btn.classList.remove('bg-gray-800', 'text-white');
                            btn.classList.add('bg-gray-200', 'text-gray-700');
                        }
                    });
                    
                } catch (error) {
                    console.error('AI comment generation failed:', error);
                    this.showError('AIコメントの生成に失敗しました');
                    loading.classList.add('hidden');
                    noApiKey.classList.remove('hidden');
                }
            },
            
            buildAIPrompt(period) {
                const now = new Date();
                const stats = this.gatherStatsForPeriod(period);
                const currentSekki = document.getElementById('currentSekki').textContent;
                const season = getActualSeason(now);
                
                let prompt = `現在は${currentSekki}の時期で、${season === 'spring' ? '春' : season === 'summer' ? '夏' : season === 'autumn' ? '秋' : '冬'}です。\n\n`;
                
                switch(period) {
                    case 'daily':
                        prompt += `今日のタスク実績:\n`;
                        prompt += `- 通常タスク: ${stats.normalCompleted}/${stats.normalTotal}完了\n`;
                        prompt += `- 目標タスク: ${stats.goalCompleted}/${stats.goalTotal}完了 (獲得ポイント: ${stats.pointsToday}pt)\n`;
                        if (stats.todayReflection) {
                            prompt += `振り返り: ${stats.todayReflection}\n`;
                        }
                        if (stats.daysToNextSekki <= 3) {
                            prompt += `※${stats.daysToNextSekki}日後に${stats.nextSekkiName}に変わります\n`;
                        }
                        prompt += `\nADHD傾向がある私に、今日の振り返りと明日へのアドバイスを400文字程度でお願いします。${stats.daysToNextSekki <= 3 ? '節気の変わり目を意識したアドバイスも含めてください。' : ''}必ず最後まで完結した文章でお願いします。`;
                        break;
                        
                    case 'weekly':
                        prompt += `今週のタスク実績:\n`;
                        prompt += `- 通常タスク: ${stats.normalCompleted}/${stats.normalTotal}完了\n`;
                        prompt += `- 目標タスク: ${stats.goalCompleted}/${stats.goalTotal}完了\n`;
                        prompt += `- 獲得ポイント: ${stats.totalPoints}pt\n`;
                        prompt += `- 期限付きタスク: ${stats.deadlineCompleted}完了\n`;
                        if (stats.weeklyReflections && stats.weeklyReflections.length > 0) {
                            prompt += `今週の振り返りテーマ: ${stats.weeklyReflections.join('、')}\n`;
                        }
                        prompt += `\nADHD傾向がある私に、今週の振り返りと来週へのアドバイスを600文字程度でお願いします。現在の${currentSekki}の季節感を意識したアドバイスを含めてください。必ず最後まで完結した文章でお願いします。`;
                        break;
                        
                    case 'sekki':
                        prompt += `${currentSekki}期間（${stats.sekkiStartDate}〜現在）のタスク実績:\n`;
                        prompt += `- 実施日数: ${stats.activeDays}日\n`;
                        prompt += `- 総ポイント: ${stats.totalPoints}pt\n`;
                        prompt += `- 平均完了率: ${stats.avgCompletionRate}%\n`;
                        prompt += `- 最も達成した目標タイプ: ${stats.topGoalTheme || 'まだデータがありません'}\n`;
                        prompt += `\n${currentSekki}という節気の特徴と季節の変化を踏まえて、ADHD傾向がある私に季節に合わせた生活のアドバイスを800文字程度でお願いします。節気の意味や季節の風物詩、体調管理のポイントなども含めてください。必ず最後まで完結した文章でお願いします。`;
                        break;
                        
                    case 'monthly':
                        prompt += `今月のタスク実績:\n`;
                        prompt += `- 実施日数: ${stats.activeDays}日\n`;
                        prompt += `- 総ポイント: ${stats.totalPoints}pt\n`;
                        prompt += `- 目標達成率: ${stats.goalCompletionRate}%\n`;
                        prompt += `- 最も多かった振り返りテーマ: ${stats.commonReflectionTheme || '特になし'}\n`;
                        prompt += `- 今月含まれる節気: ${stats.monthSekki.join('、')}\n`;
                        prompt += `\nADHD傾向がある私に、今月の総括と来月の目標設定についてアドバイスを1000文字程度でお願いします。今月通過した節気の変化も踏まえた分析を含めてください。必ず最後まで完結した文章でお願いします。`;
                        break;
                        
                    case 'quarterly':
                        prompt += `過去3ヶ月のタスク実績:\n`;
                        prompt += `- 実施日数: ${stats.activeDays}日\n`;
                        prompt += `- 総ポイント: ${stats.totalPoints}pt\n`;
                        prompt += `- 平均ポイント/日: ${stats.avgPointsPerDay}pt\n`;
                        prompt += `- 最高連続日数: ${stats.maxStreak}日\n`;
                        prompt += `- 成長傾向: ${stats.growthTrend}\n`;
                        prompt += `- 3ヶ月間に経験した節気: ${stats.quarterSekki.join('、')}\n`;
                        prompt += `- 季節の変化: ${stats.seasonalTransition}\n`;
                        prompt += `\nADHD傾向がある私に、3ヶ月間の成長と今後の長期目標についてアドバイスを2000文字程度でお願いします。季節の移り変わりとともにどのような変化があったか、季節ごとのアドバイスも含めてください。必ず最後まで完結した文章でお願いします。`;
                        break;
                }
                
                return prompt;
            },
            
            gatherStatsForPeriod(period) {
                const now = new Date();
                const stats = {};
                
                // 次の節気までの日数を計算
                const year = now.getFullYear();
                const allSekki = [...(sekkiData[year] || []), ...(sekkiData[year + 1] || [])];
                let nextSekki = null;
                for (const sekki of allSekki) {
                    if (sekki.date > now) {
                        nextSekki = sekki;
                        break;
                    }
                }
                if (nextSekki) {
                    stats.daysToNextSekki = Math.ceil((nextSekki.date - now) / (1000 * 60 * 60 * 24));
                    stats.nextSekkiName = nextSekki.name;
                }
                
                switch(period) {
                    case 'daily':
                        const todayTasks = this.getTodayTasks();
                        stats.normalCompleted = todayTasks.filter(t => t.type === 'normal' && t.isCompleted).length;
                        stats.normalTotal = todayTasks.filter(t => t.type === 'normal').length;
                        stats.goalCompleted = todayTasks.filter(t => t.type === 'urgent' && t.isCompleted).length;
                        stats.goalTotal = todayTasks.filter(t => t.type === 'urgent').length;
                        stats.pointsToday = this.dailyPointHistory[now.toDateString()] || 0;
                        stats.todayReflection = this.dailyReflections[now.toDateString()] || '';
                        break;
                        
                    case 'weekly':
                        stats.normalCompleted = 0;
                        stats.normalTotal = 0;
                        stats.goalCompleted = 0;
                        stats.goalTotal = 0;
                        stats.totalPoints = 0;
                        stats.deadlineCompleted = 0;
                        
                        for (let i = 0; i < 7; i++) {
                            const date = new Date(now);
                            date.setDate(date.getDate() - i);
                            const dateStr = date.toDateString();
                            const dayTasks = this.tasks.filter(t => new Date(t.scheduledFor).toDateString() === dateStr);
                            
                            stats.normalCompleted += dayTasks.filter(t => t.type === 'normal' && t.isCompleted).length;
                            stats.normalTotal += dayTasks.filter(t => t.type === 'normal').length;
                            stats.goalCompleted += dayTasks.filter(t => t.type === 'urgent' && t.isCompleted).length;
                            stats.goalTotal += dayTasks.filter(t => t.type === 'urgent').length;
                            stats.totalPoints += this.dailyPointHistory[dateStr] || 0;
                        }
                        
                        stats.deadlineCompleted = this.deadlineTasks.filter(t => 
                            t.isCompleted && 
                            new Date(t.completedAt) >= new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
                        ).length;
                        break;
                        
                    case 'sekki':
                        // 現在の節気の開始日を取得
                        const currentSekkiData = this.getCurrentSekkiData();
                        if (currentSekkiData) {
                            stats.sekkiStartDate = currentSekkiData.date.toLocaleDateString('ja-JP', { month: 'numeric', day: 'numeric' });
                        }
                        
                    case 'monthly':
                    case 'quarterly':
                        const days = period === 'sekki' ? 15 : period === 'monthly' ? 30 : 90;
                        stats.activeDays = 0;
                        stats.totalPoints = 0;
                        let totalTasks = 0;
                        let completedTasks = 0;
                        let goalTasks = 0;
                        let completedGoals = 0;
                        const reflectionThemes = [];
                        const weeklyReflectionSet = new Set();
                        
                        for (let i = 0; i < days; i++) {
                            const date = new Date(now);
                            date.setDate(date.getDate() - i);
                            const dateStr = date.toDateString();
                            const dayTasks = this.tasks.filter(t => new Date(t.scheduledFor).toDateString() === dateStr);
                            
                            if (dayTasks.length > 0) stats.activeDays++;
                            totalTasks += dayTasks.length;
                            completedTasks += dayTasks.filter(t => t.isCompleted).length;
                            goalTasks += dayTasks.filter(t => t.type === 'urgent').length;
                            completedGoals += dayTasks.filter(t => t.type === 'urgent' && t.isCompleted).length;
                            stats.totalPoints += this.dailyPointHistory[dateStr] || 0;
                            
                            // 振り返りの収集
                            if (this.dailyReflections[dateStr]) {
                                reflectionThemes.push(this.dailyReflections[dateStr]);
                                if (period === 'weekly' && i < 7) {
                                    weeklyReflectionSet.add(this.dailyReflections[dateStr].substring(0, 20) + '...');
                                }
                            }
                        }
                        
                        if (period === 'weekly') {
                            stats.weeklyReflections = Array.from(weeklyReflectionSet).slice(0, 3);
                        }
                        
                        stats.avgCompletionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
                        stats.goalCompletionRate = goalTasks > 0 ? Math.round((completedGoals / goalTasks) * 100) : 0;
                        stats.avgPointsPerDay = stats.activeDays > 0 ? (stats.totalPoints / stats.activeDays).toFixed(1) : 0;
                        
                        // 期間中の節気を収集
                        if (period === 'monthly' || period === 'quarterly') {
                            const sekkiSet = new Set();
                            const startDate = new Date(now);
                            startDate.setDate(startDate.getDate() - days);
                            
                            for (const sekki of allSekki) {
                                if (sekki.date >= startDate && sekki.date <= now) {
                                    sekkiSet.add(sekki.name);
                                }
                            }
                            
                            if (period === 'monthly') {
                                stats.monthSekki = Array.from(sekkiSet);
                            } else {
                                stats.quarterSekki = Array.from(sekkiSet);
                                
                                // 季節の変化を分析
                                const startSeason = getActualSeason(startDate);
                                const endSeason = getActualSeason(now);
                                if (startSeason === endSeason) {
                                    stats.seasonalTransition = `${this.getSeasonName(startSeason)}の期間`;
                                } else {
                                    stats.seasonalTransition = `${this.getSeasonName(startSeason)}から${this.getSeasonName(endSeason)}へ`;
                                }
                            }
                        }
                        
                        if (period === 'quarterly') {
                            // 連続日数計算
                            let currentStreak = 0;
                            stats.maxStreak = 0;
                            
                            for (let i = 0; i < days; i++) {
                                const date = new Date(now);
                                date.setDate(date.getDate() - i);
                                const dayTasks = this.tasks.filter(t => 
                                    new Date(t.scheduledFor).toDateString() === date.toDateString() && 
                                    t.isCompleted
                                );
                                
                                if (dayTasks.length > 0) {
                                    currentStreak++;
                                    stats.maxStreak = Math.max(stats.maxStreak, currentStreak);
                                } else {
                                    currentStreak = 0;
                                }
                            }
                            
                            // 成長傾向分析
                            const firstMonthPoints = this.calculateMonthPoints(2);
                            const lastMonthPoints = this.calculateMonthPoints(0);
                            
                            if (lastMonthPoints > firstMonthPoints * 1.2) {
                                stats.growthTrend = '上昇傾向';
                            } else if (lastMonthPoints < firstMonthPoints * 0.8) {
                                stats.growthTrend = '下降傾向';
                            } else {
                                stats.growthTrend = '安定';
                            }
                        }
                        break;
                }
                
                return stats;
            },
            
            calculateMonthPoints(monthsAgo) {
                const now = new Date();
                const startDate = new Date(now.getFullYear(), now.getMonth() - monthsAgo, 1);
                const endDate = new Date(now.getFullYear(), now.getMonth() - monthsAgo + 1, 0);
                let points = 0;
                
                for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                    points += this.dailyPointHistory[d.toDateString()] || 0;
                }
                
                return points;
            },
            
            getCurrentSekkiData() {
                const now = new Date();
                const year = now.getFullYear();
                const allSekki = [...(sekkiData[year - 1] || []), ...(sekkiData[year] || []), ...(sekkiData[year + 1] || [])];
                let currentSekki = null;
                
                for (const sekki of allSekki) {
                    if (now >= sekki.date) {
                        currentSekki = sekki;
                    } else {
                        break;
                    }
                }
                
                return currentSekki;
            },
            
            getSeasonName(season) {
                return season === 'spring' ? '春' : season === 'summer' ? '夏' : season === 'autumn' ? '秋' : '冬';
            },
            
            render() {
                const selectedDateTasks = this.getTodayTasks(); 
                const completedCount = selectedDateTasks.filter(t => t.isCompleted).length;
                const isToday = this.selectedDate.toDateString() === new Date().toDateString();

                const dateDetails = this.formatDateDetails(this.selectedDate);
                document.getElementById('currentDateYear').textContent = dateDetails.year;
                document.getElementById('currentDate').textContent = dateDetails.date;
                document.getElementById('currentDateDay').textContent = dateDetails.day;
                
                // Highlight today's date
                const calendarToggle = document.getElementById('calendarToggle');
                if (dateDetails.isToday) {
                    calendarToggle.classList.add('bg-amber-50', 'border-amber-400');
                    calendarToggle.classList.remove('border-gray-300');
                } else {
                    calendarToggle.classList.remove('bg-amber-50', 'border-amber-400');
                    calendarToggle.classList.add('border-gray-300');
                }
                document.getElementById('todayButton').classList.toggle('hidden', isToday);
                document.getElementById('completedCount').textContent = completedCount;
                document.getElementById('totalCount').textContent = selectedDateTasks.length;
                document.getElementById('totalPointsDisplay').textContent = this.totalPoints;
                document.getElementById('totalPointsStats').textContent = this.totalPoints;

                const activeNormalCount = selectedDateTasks.filter(t => t.type === 'normal' && !t.isCompleted).length;
                const activeUrgentCount = selectedDateTasks.filter(t => t.type === 'urgent' && !t.isCompleted).length;
                document.getElementById('normalSlots').textContent = Math.max(0, 3 - activeNormalCount);
                document.getElementById('urgentSlots').textContent = Math.max(0, 3 - activeUrgentCount);
                document.getElementById('normalType').disabled = (3 - activeNormalCount) <= 0;
                document.getElementById('urgentType').disabled = (3 - activeUrgentCount) <= 0;

                const taskList = document.getElementById('taskList');
                taskList.innerHTML = ''; 
                
                selectedDateTasks.sort((a,b) => new Date(a.createdAt) - new Date(b.createdAt)).forEach((task, index) => { 
                    const taskEl = document.createElement('div');
                    let taskSpecificClass = '';
                    if (task.isCompleted) { taskSpecificClass = 'task-completed'; } 
                    else if (task.type === 'urgent') { taskSpecificClass = 'task-urgent-active'; } 
                    else { taskSpecificClass = 'task-normal-active'; }
                    taskEl.className = `washi-card task-card rounded-xl p-4 mobile-compact transition-all animate-fadeInUp ${taskSpecificClass}`;
                    taskEl.style.animationDelay = `${index * 0.05}s`; 
                    
                    taskEl.innerHTML = `
                        <div class="flex items-center gap-3">
                            <button data-task-id="${task.id}" class="task-toggle-button flex-shrink-0 wa-checkbox ${task.isCompleted ? 'checked' : ''} flex items-center justify-center rounded-md"></button>
                            <div class="flex-1 min-w-0">
                                <p class="task-text-lg break-words">${task.text}</p> <!-- Removed specific color classes here, handled by parent -->
                                <div class="flex items-center gap-3 mt-1">
                                    <span class="task-type-label"> <!-- Styling now comes from parent context -->
                                        ${task.type === 'urgent' ? `【目標】${task.points ? ` ${task.points}pt` : ''}` : '【通常】'}
                                    </span>
                                    ${task.completedAt ? `<span class="task-completed-badge"><svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>完了!</span>` : ''}
                                </div>
                            </div>
                            <div class="flex items-center gap-1">
                                ${!task.isCompleted ? `
                                    <button data-task-id="${task.id}" class="task-postpone-button p-2.5 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-full transition-all min-w-[44px] min-h-[44px] flex items-center justify-center" title="明日へ">
                                        <svg class="w-5 h-5 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>
                                    </button>
                                ` : ''}
                                <button data-task-id="${task.id}" class="task-delete-button p-2.5 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded-full transition-all text-xl leading-none min-w-[44px] min-h-[44px] flex items-center justify-center" title="削除">×</button>
                            </div>
                        </div>
                    `;
                    taskList.appendChild(taskEl);
                });

                document.getElementById('noTasks').classList.toggle('hidden', selectedDateTasks.length > 0);

                const deadlineList = document.getElementById('deadlineList');
                deadlineList.innerHTML = '';
                this.deadlineTasks
                    .sort((a,b) => { /* Sort logic unchanged */
                        if (a.isCompleted && !b.isCompleted) return 1;
                        if (!a.isCompleted && b.isCompleted) return -1;
                        const daysA = this.getDaysUntilDeadline(a.deadline);
                        const daysB = this.getDaysUntilDeadline(b.deadline);
                        if (daysA !== daysB) return daysA - daysB;
                        return new Date(a.createdAt) - new Date(b.createdAt);
                    })
                    .forEach(task => {
                    const daysLeft = this.getDaysUntilDeadline(task.deadline);
                    const isUrgent = daysLeft <= 3 && daysLeft >=0 && !task.isCompleted; 
                    const isOverdue = daysLeft < 0 && !task.isCompleted;
                    const taskEl = document.createElement('div');
                    taskEl.className = `p-3 rounded-lg border transition-all ${ task.isCompleted ? 'border-gray-300 bg-gray-50 opacity-60' : isOverdue ? 'border-red-400 bg-red-50' : isUrgent ? 'border-orange-400 bg-orange-50' : 'border-gray-300 bg-gray-50' }`;
                    taskEl.innerHTML = `
                        <div class="flex items-center justify-between">
                            <div class="flex-1 min-w-0">
                                <p class="text-sm sm:text-base font-medium break-words ${task.isCompleted ? 'text-green-700' : 'text-gray-800'}">${task.text}</p>
                                <p class="text-xs sm:text-sm mt-1 ${ task.isCompleted ? 'text-gray-500' : isOverdue ? 'text-red-700 font-medium' : isUrgent ? 'text-orange-700 font-medium' : 'text-gray-600' }">
                                    ${task.isCompleted ? `✓ 完了済み (${new Date(task.completedAt).toLocaleDateString('ja-JP', {month:'numeric', day:'numeric'})})` : isOverdue ? `${Math.abs(daysLeft)}日超過` : daysLeft === 0 ? '本日まで' : `あと${daysLeft}日`}
                                    ・期限: ${new Date(task.deadline).toLocaleDateString('ja-JP', { month: 'numeric', day: 'numeric' })}
                                </p>
                            </div>
                            <!-- Action buttons for deadline tasks -->
                            <div class="flex items-center gap-1 ml-2">
                                <button data-task-id="${task.id}" class="deadline-task-toggle-button flex-shrink-0 wa-checkbox ${task.isCompleted ? 'checked' : ''} flex items-center justify-center rounded-md" style="min-width: 36px; min-height: 36px; width: 36px; height: 36px;"></button>
                                <!-- NEW: Delete button for deadline task -->
                                <button data-task-id="${task.id}" class="deadline-task-delete-button p-2 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded-full transition-all text-lg leading-none" title="削除">×</button>
                            </div>
                        </div>
                    `;
                    deadlineList.appendChild(taskEl);
                });

                const activeDeadlines = this.deadlineTasks.filter(t => !t.isCompleted).length;
                document.getElementById('noDeadlineTasks').classList.toggle('hidden', this.deadlineTasks.length > 0);
                const deadlineToggleButton = document.getElementById('deadlineToggle');
                deadlineToggleButton.disabled = activeDeadlines >= 3;
                deadlineToggleButton.querySelector('svg').style.opacity = activeDeadlines >= 3 ? '0.3' : '1';

                const inboxList = document.getElementById('inboxList');
                inboxList.innerHTML = '';
                this.inboxItems.forEach(item => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'flex items-center justify-between p-3 bg-gray-50 rounded-lg text-gray-700 border border-gray-200 text-sm';
                    itemEl.innerHTML = `
                        <span class="break-all">${item.text}</span>
                        <button data-item-id="${item.id}" class="inbox-item-delete-button ml-2 p-1 text-gray-400 hover:text-red-500 text-lg leading-none">×</button>
                    `;
                    inboxList.appendChild(itemEl);
                });
                
                // 振り返り表示
                const dateStr = this.selectedDate.toDateString();
                const reflection = this.dailyReflections[dateStr];
                const reflectionDisplay = document.getElementById('reflectionDisplay');
                const noReflection = document.getElementById('noReflection');
                
                if (reflection) {
                    reflectionDisplay.textContent = reflection;
                    reflectionDisplay.classList.remove('hidden');
                    noReflection.classList.add('hidden');
                } else {
                    reflectionDisplay.classList.add('hidden');
                    noReflection.classList.remove('hidden');
                }
                
                // AIコメント表示
                const aiCommentDisplay = document.getElementById('aiCommentDisplay');
                const noApiKey = document.getElementById('noApiKey');
                const aiCommentContent = document.getElementById('aiCommentContent');
                const aiCommentLoading = document.getElementById('aiCommentLoading');
                
                if (this.openaiApiKey) {
                    noApiKey.classList.add('hidden');
                    if (!aiCommentContent.textContent && !aiCommentLoading.classList.contains('hidden')) {
                        aiCommentContent.classList.add('hidden');
                    }
                } else {
                    noApiKey.classList.remove('hidden');
                    aiCommentContent.classList.add('hidden');
                    aiCommentLoading.classList.add('hidden');
                }
                
                this.bindDynamicEvents();
            },

            bindDynamicEvents() {
                document.querySelectorAll('.task-toggle-button').forEach(button => { button.addEventListener('click', (e) => this.toggleTask(e.currentTarget.dataset.taskId)); });
                document.querySelectorAll('.task-postpone-button').forEach(button => { button.addEventListener('click', (e) => this.postponeTask(e.currentTarget.dataset.taskId)); });
                document.querySelectorAll('.task-delete-button').forEach(button => { button.addEventListener('click', (e) => this.deleteTask(e.currentTarget.dataset.taskId)); });
                
                document.querySelectorAll('.deadline-task-toggle-button').forEach(button => { button.addEventListener('click', (e) => this.toggleDeadlineTask(e.currentTarget.dataset.taskId)); });
                // --- NEW: Bind delete for deadline tasks ---
                document.querySelectorAll('.deadline-task-delete-button').forEach(button => {
                    button.addEventListener('click', (e) => this.deleteDeadlineTask(e.currentTarget.dataset.taskId));
                });

                document.querySelectorAll('.inbox-item-delete-button').forEach(button => { button.addEventListener('click', (e) => this.deleteInboxItem(e.currentTarget.dataset.itemId)); });
                document.querySelectorAll('button:not([data-ripple-bound])').forEach(button => {
                    button.style.position = 'relative'; 
                    button.style.overflow = 'hidden';  
                    button.addEventListener('click', createRipple);
                    button.setAttribute('data-ripple-bound', 'true'); 
                });
            }
        };
        app.init();
        
        // Initialize calendar input on load
        const dateInputEl = document.getElementById('dateInput');
        dateInputEl.value = app.selectedDate.toISOString().split('T')[0];
        app.updateCalendarSekkiInfo();
        
        // Service Workerの登録
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => console.log('ServiceWorker registration successful:', registration.scope))
                    .catch(err => console.log('ServiceWorker registration failed:', err));
            });
        }
        
        // PWAインストールプロンプト
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            // インストールボタンは表示しない
        });
    </script>
</body>
</html>

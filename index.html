<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>二十四節気タスク管理</title>

    <!-- Favicon Links: Added for bookmarking and browser tabs -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%23fdfdfd'/%3E%3Cpath d='M 50 0 A 50 50 0 0 1 100 50 L 50 50 Z' fill='%23a7e0e8'/%3E%3Cpath d='M 100 50 A 50 50 0 0 1 50 100 L 50 50 Z' fill='%23e09a73'/%3E%3Cpath d='M 50 100 A 50 50 0 0 1 0 50 L 50 50 Z' fill='%23ddebf0'/%3E%3Cpath d='M 0 50 A 50 50 0 0 1 50 0 L 50 50 Z' fill='%23ffd9e1'/%3E%3Ccircle cx='50' cy='50' r='22' fill='%23fdfdfd'/%3E%3Ctext x='50' y='62' font-family='Shippori Mincho, serif' font-size='38' fill='%234a4a4a' text-anchor='middle'%3E暦%3C/text%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%23fdfdfd'/%3E%3Cpath d='M 50 0 A 50 50 0 0 1 100 50 L 50 50 Z' fill='%23a7e0e8'/%3E%3Cpath d='M 100 50 A 50 50 0 0 1 50 100 L 50 50 Z' fill='%23e09a73'/%3E%3Cpath d='M 50 100 A 50 50 0 0 1 0 50 L 50 50 Z' fill='%23ddebf0'/%3E%3Cpath d='M 0 50 A 50 50 0 0 1 50 0 L 50 50 Z' fill='%23ffd9e1'/%3E%3Ccircle cx='50' cy='50' r='22' fill='%23fdfdfd'/%3E%3Ctext x='50' y='62' font-family='Shippori Mincho, serif' font-size='38' fill='%234a4a4a' text-anchor='middle'%3E暦%3C/text%3E%3C/svg%3E">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;700&family=Zen+Old+Mincho&display=swap');
        
        body {
            font-family: 'Shippori Mincho', serif;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .sekki-title {
            font-family: 'Zen Old Mincho', serif;
        }
        
        /* 季節ごとの背景 - 和の伝統色 */
        .bg-spring {  
            background:  
                radial-gradient(circle at 20% 80%, rgba(255, 183, 197, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 214, 221, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(255, 240, 245, 0.2) 0%, transparent 50%),
                linear-gradient(135deg, #faf0e6 0%, #fff5ee 100%);
            position: relative;
            overflow: hidden;
        }
        .bg-summer {  /* 海のテーマに変更 */
            background:
                /* Sun glare */
                radial-gradient(ellipse at 70% 15%, rgba(255, 235, 180, 0.5) 0%, rgba(255, 235, 180, 0) 45%),
                /* Water layers */
                linear-gradient(to bottom,
                    #B2EBF2 0%,  /* Light Cyan / Sky Blueish */
                    #80DEEA 25%, /* Medium Cyan */
                    #4DD0E1 50%, /* Cyan */
                    #26C6DA 75%, /* Darker Cyan */
                    #00BCD4 100% /* Deep Cyan */
                );
            position: relative;
            overflow: hidden;
        }
        .bg-autumn {  
            background:  
                radial-gradient(circle at 20% 80%, rgba(219, 112, 47, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 218, 185, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(255, 248, 220, 0.2) 0%, transparent 50%),
                linear-gradient(135deg, #fdf5e6 0%, #ffefd5 100%);
            position: relative;
            overflow: hidden;
        }
        .bg-winter {  
            background:  
                radial-gradient(circle at 20% 80%, rgba(135, 206, 235, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(176, 224, 230, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(240, 248, 255, 0.3) 0%, transparent 50%),
                linear-gradient(135deg, #e6f3ff 0%, #f0f8ff 100%);
            position: relative;
            overflow: hidden;
        }
        
        /* 季節のアニメーション背景 */
        .season-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            overflow: hidden;
        }
        
        /* 桜の花びら */
        .sakura-petal {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle at 30% 30%, #ffb7c5 0%, #ffc0cb 50%, rgba(255, 192, 203, 0.8) 100%);
            border-radius: 0 100% 0 100%;
            opacity: 0;
            animation: sakuraFall linear infinite;
        }
        
        /* 夏の気泡 (海のテーマ) */
        .sea-bubble {
            position: absolute;
            background: radial-gradient(circle at 30% 30%, rgba(220, 235, 255, 0.8) 0%, rgba(180, 210, 255, 0.5) 60%, rgba(230, 240, 255, 0.3) 100%);
            border-radius: 50%;
            opacity: 0;
            animation: bubbleRise linear infinite;
            box-shadow: inset 0 0 3px rgba(255,255,255,0.6), 0 1px 2px rgba(100,150,200,0.2);
        }
        
        /* 紅葉 */
        .autumn-leaf {
            position: absolute;
            width: 25px;
            height: 25px;
            background: linear-gradient(135deg, #d2691e 0%, #ff6347 50%, #ff8c00 100%);
            clip-path: polygon(50% 0%, 60% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 40% 35%);
            opacity: 0;
            animation: autumnFall linear infinite;
        }
        
        /* 雪の結晶 */
        .snow-flake {
            position: absolute;
            width: 15px;  
            height: 15px;  
            background: radial-gradient(circle, rgba(255, 255, 255, 0.95) 0%, rgba(240, 248, 255, 0.75) 70%, transparent 100%);
            border-radius: 50%;  
            opacity: 0;
            animation: largeSnowFall linear infinite;  
        }
        
        /* アニメーション定義 */
        @keyframes sakuraFall {
            0% { transform: translateY(-20px) translateX(0) rotate(-45deg); opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.8; }
            100% { transform: translateY(calc(100vh + 20px)) translateX(100px) rotate(315deg); opacity: 0; }
        }

        @keyframes bubbleRise { /* 夏の気泡アニメーション */
            0% {
                transform: translateY(100vh) translateX(0px) scale(0.2);
                opacity: 0;
            }
            10% {
                opacity: 0.7;
                transform: translateY(90vh) translateX(calc(sin(1turn) * 10px)) scale(0.4);
            }
            50% {
                transform: translateY(40vh) translateX(calc(sin(2turn) * -15px)) scale(0.7);
                opacity: 0.9;
            }
            90% {
                opacity: 0.5;
                transform: translateY(5vh) translateX(calc(sin(3turn) * 10px)) scale(1);
            }
            100% {
                transform: translateY(-10vh) translateX(calc(sin(3.5turn) * 5px)) scale(1.1);
                opacity: 0;
            }
        }

        @keyframes autumnFall {
            0% { transform: translateY(-30px) translateX(0) rotate(0deg); opacity: 0; }
            10% { opacity: 0.9; }
            90% { opacity: 0.9; }
            100% { transform: translateY(calc(100vh + 30px)) translateX(-80px) rotate(360deg); opacity: 0; }
        }
        @keyframes largeSnowFall {
            0% { transform: translateY(-50px) translateX(0) rotate(0deg); opacity: 0; }
            10% { opacity: 0.9; }
            25% { transform: translateY(calc(25vh - 50px)) translateX(-20px) rotate(90deg); }
            50% { transform: translateY(calc(50vh - 50px)) translateX(20px) rotate(180deg); }
            75% { transform: translateY(calc(75vh - 50px)) translateX(-15px) rotate(270deg); }
            90% { opacity: 0.9; }
            100% { transform: translateY(calc(100vh + 50px)) translateX(30px) rotate(360deg); opacity: 0; }
        }
        
        /* 波紋エフェクト */
        @keyframes ripple {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(4); opacity: 0; }
        }
        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            animation: ripple 1s ease-out;
        }
        
        /* 和紙風カード */
        .washi-card {
            background: repeating-linear-gradient(90deg, rgba(255,255,255,0.9), rgba(255,255,255,0.9) 1px, rgba(255,255,255,0.95) 1px, rgba(255,255,255,0.95) 3px), rgba(255,255,255,0.92);
            backdrop-filter: blur(8px);
            box-shadow: 0 3px 12px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.5);  
            border: 1px solid rgba(0,0,0,0.08);  
        }
        
        /* スマホ用調整 */
        @media (max-width: 640px) {
            .task-text-lg { font-size: 1.05rem; line-height: 1.55; }  
            .button-large { min-height: 48px; font-size: 1rem; }
            .sekki-grid { grid-template-columns: repeat(3, 1fr) !important; }
            .mobile-compact { padding: 0.75rem !important; }
            .mobile-text-sm { font-size: 0.875rem !important; }
            .mobile-gap-2 { gap: 0.5rem !important; }
            .point-display-mobile { 
                flex-direction: column !important; 
                align-items: flex-start !important;
                gap: 0.5rem !important;
            }
        }
        
        @media (hover: none) {
            .wa-button:active { transform: scale(0.95); }
        }
        
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fadeInUp { animation: fadeInUp 0.8s ease-out forwards; }
        
        /* チェックボックス */
        .wa-checkbox {
            border: 2px solid #8b7355;
            position: relative;
            transition: all 0.3s ease;
            min-width: 44px;
            min-height: 44px;
            -webkit-tap-highlight-color: transparent;
        }
        .wa-checkbox.checked { background-color: #8b7355; border-color: #8b7355; }
        .wa-checkbox.checked::after {
            content: ''; position: absolute; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3'%3E%3Cpath d='M5 13l4 4L19 7'/%3E%3C/svg%3E");
            background-size: 70%; background-position: center; background-repeat: no-repeat;
        }
        
        .hidden { display: none; }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .gradient-animation { background-size: 200% 200%; animation: gradientShift 15s ease infinite; }

        /* --- タスク表示改善のためのスタイル --- */
        .task-card {  
             box-shadow: 0 4px 15px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.5);  
        }
        .task-text-lg {  
            font-size: 1.1rem;  
            line-height: 1.6;
        }
        .task-type-label {  
            font-size: 0.8rem;  
            padding: 2px 6px;
            border-radius: 0.375rem; /* rounded-md */
        }
        
        /* 未完了の通常タスク */
        .task-normal-active {
            background-color: #FEFBF3; /* 温かみのあるクリーム色 */
            border: 1px solid #D4C2AD; /* やや濃いめの枠線 */
            box-shadow: 0 3px 8px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.6);
        }
        .task-normal-active .task-text-lg {
            color: #5D4037; /* 濃い茶色の文字 */
        }
        .task-normal-active .task-type-label {
            background-color: #E0D8CC; /* カードに合わせたベージュ */
            color: #6A5ACD; /* SlateBlue 文字 */
            font-weight: 500;
        }

        /* 未完了の目標タスク */
        .task-urgent-active {
            background-color: rgba(255, 235, 224, 0.98); /* 薄いオレンジ */
            border: 2px solid #FF8C69; /* やや濃いオレンジの枠線 */
        }
         .task-urgent-active .task-text-lg {
            color: #BF360C; /* 深いオレンジ/茶色の文字 */
        }
        .task-urgent-active .task-type-label {
            background-color: #FF4500; /* 明るい赤オレンジ */
            color: white;
            font-weight: bold;
        }

        /* 完了済みタスク */
        .task-completed {
            background-color: rgba(236, 253, 245, 0.95);  
            border: 2px solid #10b981;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.15);
            position: relative;
            overflow: hidden;
        }
        .task-completed::before {
            content: '✓';
            position: absolute;
            top: -5px;
            right: 10px;
            font-size: 3rem;
            color: rgba(16, 185, 129, 0.2);
            font-weight: bold;
        }
        .task-completed .task-text-lg {
            color: #059669;
            font-weight: 500;
        }
        .task-completed .task-type-label {
             background-color: #10b981;
             color: white;
             font-weight: bold;
        }
        .task-completed-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            background-color: #10b981;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="backgroundSeason" class="min-h-screen bg-summer gradient-animation transition-all duration-1000 relative">
        <!-- 季節のアニメーション -->
        <div id="seasonAnimation" class="season-animation"></div>
        
        <div class="max-w-2xl mx-auto px-4 py-4 relative z-10">
            <!-- 節気ヘッダー -->
            <div class="washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp">
                <div class="text-center mb-4">
                    <h1 class="text-3xl sm:text-5xl font-bold text-gray-800 mb-2 sekki-title">
                        <span id="currentSekki"></span>
                    </h1>
                    <div class="text-base sm:text-lg text-gray-700 mb-1">
                        <span id="sekkiDate"></span>
                    </div>
                    <div id="nextSekkiInfo" class="text-sm text-gray-600"></div>
                </div>
                
                <div class="flex items-center justify-between mb-3">
                    <h2 class="text-lg sm:text-xl font-semibold text-gray-800">本日の予定</h2>
                    <div class="flex items-center gap-2">
                        <button id="statsToggle" class="p-3 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-lg transition-all" title="ポイント統計">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                            </svg>
                        </button>
                        <button id="inboxToggle" class="p-3 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-lg transition-all">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <!-- 日付選択 -->
                <div class="flex flex-col gap-3">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-1">
                            <button id="prevDay" class="p-3 hover:bg-gray-100 rounded-full transition-all">
                                <svg class="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                                </svg>
                            </button>
                            
                            <button id="calendarToggle" class="flex items-center gap-2 px-3 sm:px-6 py-3 hover:bg-gray-50 rounded-full transition-all">
                                <span id="currentDate" class="text-base sm:text-lg font-medium text-gray-800"></span>
                            </button>
                            
                            <button id="nextDay" class="p-3 hover:bg-gray-100 rounded-full transition-all">
                                <svg class="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                </svg>
                            </button>
                        </div>
                        
                        <div class="flex items-center gap-3 point-display-mobile">
                            <div class="flex items-center gap-2 bg-gray-50 px-3 sm:px-4 py-2 rounded-full">
                                <span id="completedCount" class="text-xl sm:text-3xl font-bold text-gray-800">0</span>
                                <span class="text-base sm:text-xl text-gray-500">／</span>
                                <span id="totalCount" class="text-lg sm:text-2xl text-gray-700">0</span>
                            </div>
                            <div class="flex items-center gap-2 bg-amber-50 px-3 sm:px-4 py-2 rounded-full">
                                <svg class="w-4 sm:w-5 h-4 sm:h-5 text-amber-600" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                                </svg>
                                <span id="totalPointsDisplay" class="text-base sm:text-xl font-bold text-amber-700">0</span>
                                <span class="text-sm text-amber-600">pt</span>
                            </div>
                        </div>
                    </div>
                    
                    <button id="todayButton" class="hidden w-full py-3 text-base font-medium text-white bg-gradient-to-r from-gray-700 to-gray-800 hover:from-gray-800 hover:to-gray-900 rounded-full transition-all button-large">
                        本日へ戻る
                    </button>
                </div>
                
                <!-- カレンダー -->
                <div id="calendarInput" class="hidden mt-4 animate-fadeInUp">
                    <input type="date" id="dateInput" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 transition-all text-base">
                    <div id="calendarSekkiInfo" class="mt-3 p-3 bg-gray-50 rounded-lg text-sm text-gray-600"></div>
                </div>
            </div>

            <!-- エラーメッセージ -->
            <div id="errorMessage" class="hidden bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg mb-4 animate-fadeInUp"></div>

            <!-- 期限付きタスク -->
            <div class="washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp" style="animation-delay: 0.1s">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-base sm:text-lg font-semibold text-gray-800">期限付きタスク</h3>
                    <button id="deadlineToggle" class="p-3 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-full transition-all">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                        </svg>
                    </button>
                </div>

                <div id="deadlineForm" class="hidden mb-4 p-3 bg-gray-50 rounded-xl animate-fadeInUp">
                    <div class="flex flex-col gap-3">
                        <input type="text" id="deadlineText" placeholder="タスク内容..." class="px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 transition-all text-base">
                        <div class="flex gap-2">
                            <input type="date" id="deadlineDate" class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 transition-all text-base">
                            <button id="addDeadline" class="px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-800 transition-all">追加</button>
                            <button id="cancelDeadline" class="px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-lg transition-all">×</button>
                        </div>
                    </div>
                </div>

                <div id="deadlineList" class="space-y-2"></div>
                <p id="noDeadlineTasks" class="text-center py-4 text-gray-500 text-sm">期限付きタスクはありません</p>
            </div>

            <!-- タスク入力 -->
            <div class="washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp" style="animation-delay: 0.2s">
                <div class="flex gap-2 mb-3">
                    <button id="normalType" class="flex-1 px-4 py-2 rounded-full font-medium transition-all bg-gray-800 text-white button-large">
                        通常 <span class="text-sm opacity-80">(<span id="normalSlots">3</span>/3)</span>
                    </button>
                    <button id="urgentType" class="flex-1 px-4 py-2 rounded-full font-medium transition-all bg-gray-100 text-gray-700 hover:bg-gray-200 button-large">
                        目標 <span class="text-sm opacity-80">(<span id="urgentSlots">3</span>/3)</span>
                    </button>
                </div>
                
                <div class="flex flex-col gap-2">
                    <input type="text" id="taskInput" placeholder="本日の予定を入力..." class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 transition-all text-base">
                    <div id="pointSelector" class="hidden flex items-center gap-2 mobile-gap-2">
                        <span class="text-sm font-medium text-gray-700 mobile-text-sm">ポイント:</span>
                        <button class="point-button px-3 py-2 sm:py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 hover:bg-gray-300 min-w-[44px]" data-points="1">1pt</button>
                        <button class="point-button px-3 py-2 sm:py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 hover:bg-gray-300 min-w-[44px]" data-points="2">2pt</button>
                        <button class="point-button px-3 py-2 sm:py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 hover:bg-gray-300 min-w-[44px]" data-points="3">3pt</button>
                        <button id="confirmAddTask" class="ml-auto px-4 py-2 sm:py-1 bg-gray-800 text-white rounded-lg hover:bg-gray-900 text-sm font-medium">追加</button>
                    </div>
                    <button id="addTask" class="px-6 py-3 bg-gray-800 text-white rounded-lg hover:bg-gray-900 transition-all font-medium button-large">
                        <svg class="w-5 h-5 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- タスクリスト -->
            <div id="taskList" class="space-y-3 mb-4"></div>
            <p id="noTasks" class="hidden text-center py-8 text-gray-500">本日の予定はありません</p>

            <!-- 日々の振り返り -->
            <div class="washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-base sm:text-lg font-semibold text-gray-800">今日の振り返り</h3>
                    <button id="reflectionToggle" class="p-3 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-full transition-all">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
                        </svg>
                    </button>
                </div>
                
                <div id="reflectionForm" class="hidden space-y-3">
                    <textarea id="reflectionInput" placeholder="今日はどんな一日でしたか？短くても大丈夫です..." 
                              class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 transition-all text-base resize-none" 
                              rows="3"></textarea>
                    <div class="flex gap-2">
                        <button id="saveReflection" class="px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-800 transition-all">保存</button>
                        <button id="cancelReflection" class="px-3 py-2 text-gray-700 hover:bg-gray-100 rounded-lg transition-all">キャンセル</button>
                    </div>
                </div>
                
                <div id="reflectionDisplay" class="text-sm sm:text-base text-gray-700 leading-relaxed"></div>
                <p id="noReflection" class="text-center py-4 text-gray-500 text-sm">まだ振り返りが書かれていません</p>
            </div>

            <!-- ポイント統計 -->
            <div id="statsSection" class="hidden washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp">
                <h3 class="text-base sm:text-lg font-semibold text-gray-800 mb-4">ポイント統計</h3>
                <div class="space-y-4">
                    <div class="bg-amber-50 rounded-lg p-4">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-medium text-gray-700">累計ポイント</span>
                            <div class="flex items-center gap-2">
                                <svg class="w-6 h-6 text-amber-600" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                                </svg>
                                <span class="text-2xl font-bold text-amber-700" id="totalPointsStats">0</span>
                                <span class="text-lg text-amber-600">pt</span>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h4 class="text-sm font-medium text-gray-700 mb-2">最近7日間の獲得ポイント</h4>
                        <div id="weeklyStats" class="space-y-2">
                            <!-- 週間統計がここに表示されます -->
                        </div>
                    </div>
                    
                    <div class="border-t pt-3">
                        <button id="resetStats" class="w-full px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-all text-sm font-medium">
                            統計をリセット
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- アイデア置き場 -->
            <div id="inboxSection" class="hidden washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp">
                <h3 class="text-base sm:text-lg font-semibold text-gray-800 mb-3">覚書</h3>
                <div class="flex gap-2 mb-3">
                    <input type="text" id="inboxInput" placeholder="思いついたことをメモ..." class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 transition-all text-base">
                    <button id="addInbox" class="px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-800 transition-all">記録</button>
                </div>
                <div id="inboxList" class="space-y-2"></div>
            </div>
            
            <!-- AIコメント -->
            <div id="aiCommentSection" class="washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-base sm:text-lg font-semibold text-gray-800">AIからのメッセージ</h3>
                    <button id="aiSettingsToggle" class="p-2 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-lg transition-all text-sm">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                        </svg>
                    </button>
                </div>
                
                <!-- APIキー設定 -->
                <div id="apiKeyForm" class="hidden mb-4 p-3 bg-gray-50 rounded-xl">
                    <label class="block text-sm font-medium text-gray-700 mb-2">OpenAI APIキー</label>
                    <input type="password" id="apiKeyInput" placeholder="sk-..." 
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-gray-600 text-sm">
                    <div class="flex gap-2 mt-2">
                        <button id="saveApiKey" class="px-3 py-1 bg-gray-700 text-white rounded text-sm">保存</button>
                        <button id="cancelApiKey" class="px-3 py-1 text-gray-700 hover:bg-gray-100 rounded text-sm">キャンセル</button>
                    </div>
                </div>
                
                <!-- 期間選択 -->
                <div id="aiPeriodSelector" class="flex flex-wrap gap-2 mb-3">
                    <button class="ai-period-button px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 hover:bg-gray-300" data-period="daily">デイリー</button>
                    <button class="ai-period-button px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 hover:bg-gray-300" data-period="weekly">週間</button>
                    <button class="ai-period-button px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 hover:bg-gray-300" data-period="sekki">節気間</button>
                    <button class="ai-period-button px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 hover:bg-gray-300" data-period="monthly">月間</button>
                    <button class="ai-period-button px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 hover:bg-gray-300" data-period="quarterly">3ヶ月</button>
                </div>
                
                <!-- AIコメント表示 -->
                <div id="aiCommentDisplay" class="bg-gradient-to-br from-blue-50 to-purple-50 rounded-lg p-4">
                    <div id="aiCommentContent" class="text-sm sm:text-base text-gray-700 leading-relaxed whitespace-pre-wrap max-h-96 overflow-y-auto"></div>
                    <div id="aiCommentLoading" class="hidden text-center py-8">
                        <div class="inline-flex items-center gap-2 text-gray-600">
                            <svg class="animate-spin h-5 w-5" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span>AIがコメントを作成中...</span>
                        </div>
                    </div>
                    <p id="noApiKey" class="text-center py-4 text-gray-500 text-sm">APIキーを設定してAIコメントを受け取りましょう</p>
                </div>
            </div>
            
            <!-- 節気の説明 -->
            <div class="washi-card rounded-2xl p-4 sm:p-6 mb-4 animate-fadeInUp">
                <h3 class="text-base sm:text-lg font-semibold text-gray-800 mb-3 text-center">二十四節気</h3>
                <div class="text-center mb-3">
                    <span id="sekkiDetailName" class="text-xl sm:text-2xl font-bold text-gray-800 sekki-title"></span>
                    <div id="sekkiDetailDate" class="text-xs sm:text-sm text-gray-600 mt-1"></div>
                </div>
                <p id="sekkiDescription" class="text-sm sm:text-base text-gray-700 leading-relaxed mb-4"></p>
                <div class="border-t border-gray-200 pt-3">
                    <p class="text-xs sm:text-sm text-gray-600 text-center mb-2">今年の二十四節気</p>
                    <div id="yearSekkiList" class="grid grid-cols-3 sm:grid-cols-4 gap-1 sm:gap-2 text-xs sm:text-sm sekki-grid"></div>
                </div>
            </div>
        </div>

        <!-- セレブレーション -->
        <div id="celebration" class="hidden fixed inset-0 pointer-events-none flex items-center justify-center z-50">
            <div class="relative">
                <div class="absolute inset-0 bg-amber-500 rounded-full animate-ping"></div>
                <div class="relative washi-card rounded-2xl p-8 sm:p-10 animate-fadeInUp">
                    <div class="text-center">
                        <div class="text-3xl sm:text-4xl mb-2 sekki-title">完了</div>
                        <p class="text-lg sm:text-xl text-gray-700">タスク完了</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 先送りエフェクト -->
        <div id="postponeEffect" class="hidden fixed bottom-4 right-4 washi-card rounded-xl p-4 animate-fadeInUp flex items-center gap-2">
            <svg class="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
            </svg>
            <span class="text-base font-medium text-gray-700">明日へ</span>
        </div>
    </div>

    <script>
        // 実際の季節を月から判定する関数
        function getActualSeason(date) {
            const month = date.getMonth() + 1; // 0-11 を 1-12 に変換
            if (month >= 3 && month <= 5) return 'spring';
            if (month >= 6 && month <= 8) return 'summer';
            if (month >= 9 && month <= 11) return 'autumn';
            return 'winter';
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            const now = new Date();
            const actualSeason = getActualSeason(now);
            const bg = document.getElementById('backgroundSeason');
            bg.className = bg.className.replace(/bg-(spring|summer|autumn|winter)/g, '');
            bg.classList.add(`bg-${actualSeason}`);
            app.updateSekki();
        });

        const sekkiData = { // Sekki data remains the same
            2025: [
                { name: '小寒', date: new Date('2025-01-05T11:33:00'), season: 'winter', description: '寒さが最も厳しくなる前の時期。この日から寒の入りとなります。' },
                { name: '大寒', date: new Date('2025-01-20T05:00:00'), season: 'winter', description: '一年で最も寒さが厳しい時期。寒稽古など、寒さを利用した行事が行われます。' },
                { name: '立春', date: new Date('2025-02-03T23:10:00'), season: 'spring', description: '暦の上での春の始まり。梅の花が咲き始め、徐々に暖かくなり始めます。' },
                { name: '雨水', date: new Date('2025-02-18T19:07:00'), season: 'spring', description: '雪が雨に変わり、積もった雪が溶け始める頃。農耕の準備を始める目安です。' },
                { name: '啓蟄', date: new Date('2025-03-05T17:07:00'), season: 'spring', description: '冬ごもりしていた虫が、春の暖かさを感じて地中から姿を現す頃。' },
                { name: '春分', date: new Date('2025-03-20T18:01:00'), season: 'spring', description: '昼と夜の長さがほぼ等しくなる日。自然をたたえ生物をいつくしむ日です。' },
                { name: '清明', date: new Date('2025-04-04T21:49:00'), season: 'spring', description: '万物が清らかで明るく、生き生きとした様子を見せる頃。花見の季節です。' },
                { name: '穀雨', date: new Date('2025-04-20T04:56:00'), season: 'spring', description: '春の雨が降り、穀物の成長を助ける頃。種まきの好機とされています。' },
                { name: '立夏', date: new Date('2025-05-05T14:57:00'), season: 'summer', description: '暦の上での夏の始まり。新緑が美しく、過ごしやすい気候になります。' },
                { name: '小満', date: new Date('2025-05-21T03:55:00'), season: 'summer', description: '陽気が良くなり、万物が成長して天地に満ち始める頃。麦の穂が実り始めます。' },
                { name: '芒種', date: new Date('2025-06-05T18:57:00'), season: 'summer', description: '稲などの穀物の種をまく時期。梅雨入りの頃でもあります。' },
                { name: '夏至', date: new Date('2025-06-21T11:42:00'), season: 'summer', description: '一年で最も昼が長く夜が短い日。本格的な夏の到来を告げます。' },
                { name: '小暑', date: new Date('2025-07-07T05:05:00'), season: 'summer', description: '暑さが本格的になる頃。梅雨明けが近づき、蝉が鳴き始めます。' },
                { name: '大暑', date: new Date('2025-07-22T22:29:00'), season: 'summer', description: '一年で最も暑さが厳しい時期。夏の土用の時期でもあります。' },
                { name: '立秋', date: new Date('2025-08-07T14:52:00'), season: 'autumn', description: '暦の上での秋の始まり。まだ暑いですが、朝夕は涼しくなり始めます。' },
                { name: '処暑', date: new Date('2025-08-23T05:34:00'), season: 'autumn', description: '暑さが和らぐ頃。朝晩の涼しさに秋の気配を感じ始めます。' },
                { name: '白露', date: new Date('2025-09-07T17:52:00'), season: 'autumn', description: '草花に朝露が宿り始める頃。日中は暖かくても朝晩は冷え込みます。' },
                { name: '秋分', date: new Date('2025-09-23T03:19:00'), season: 'autumn', description: '昼と夜の長さがほぼ等しくなる日。秋彼岸の中日でもあります。' },
                { name: '寒露', date: new Date('2025-10-08T09:41:00'), season: 'autumn', description: '露が冷たく感じられる頃。秋が深まり、紅葉が美しくなります。' },
                { name: '霜降', date: new Date('2025-10-23T12:51:00'), season: 'autumn', description: '露が霜に変わり始める頃。朝晩の冷え込みが厳しくなります。' },
                { name: '立冬', date: new Date('2025-11-07T13:04:00'), season: 'winter', description: '暦の上での冬の始まり。日差しが弱まり、冬の気配を感じ始めます。' },
                { name: '小雪', date: new Date('2025-11-22T10:36:00'), season: 'winter', description: '雪が降り始める頃。まだ積もるほどではない、わずかな雪を指します。' },
                { name: '大雪', date: new Date('2025-12-07T06:05:00'), season: 'winter', description: '本格的に雪が降り始める頃。山々は雪に覆われ、平地でも雪が降ります。' },
                { name: '冬至', date: new Date('2025-12-22T00:03:00'), season: 'winter', description: '一年で最も昼が短く夜が長い日。ゆず湯に入り、かぼちゃを食べる風習があります。' }
            ],
            2026: [ // Data for 2026 remains for future-proofing
                { name: '小寒', date: new Date('2026-01-05T17:24:00'), season: 'winter', description: '寒さが最も厳しくなる前の時期。この日から寒の入りとなります。' },
                { name: '大寒', date: new Date('2026-01-20T10:46:00'), season: 'winter', description: '一年で最も寒さが厳しい時期。寒稽古など、寒さを利用した行事が行われます。' },
                { name: '立春', date: new Date('2026-02-04T05:03:00'), season: 'spring', description: '暦の上での春の始まり。梅の花が咲き始め、徐々に暖かくなり始めます。' },
                { name: '雨水', date: new Date('2026-02-19T00:51:00'), season: 'spring', description: '雪が雨に変わり、積もった雪が溶け始める頃。農耕の準備を始める目安です。' },
                { name: '啓蟄', date: new Date('2026-03-05T22:58:00'), season: 'spring', description: '冬ごもりしていた虫が、春の暖かさを感じて地中から姿を現す頃。' },
                { name: '春分', date: new Date('2026-03-20T23:41:00'), season: 'spring', description: '昼と夜の長さがほぼ等しくなる日。自然をたたえ生物をいつくしむ日です。' },
                { name: '清明', date: new Date('2026-04-05T03:35:00'), season: 'spring', description: '万物が清らかで明るく、生き生きとした様子を見せる頃。花見の季節です。' },
                { name: '穀雨', date: new Date('2026-04-20T10:31:00'), season: 'spring', description: '春の雨が降り、穀物の成長を助ける頃。種まきの好機とされています。' },
                { name: '立夏', date: new Date('2026-05-05T20:41:00'), season: 'summer', description: '暦の上での夏の始まり。新緑が美しく、過ごしやすい気候になります。' },
                { name: '小満', date: new Date('2026-05-21T09:28:00'), season: 'summer', description: '陽気が良くなり、万物が成長して天地に満ち始める頃。麦の穂が実り始めます。' },
                { name: '芒種', date: new Date('2026-06-06T00:40:00'), season: 'summer', description: '稲などの穀物の種をまく時期。梅雨入りの頃でもあります。' },
                { name: '夏至', date: new Date('2026-06-21T17:16:00'), season: 'summer', description: '一年で最も昼が長く夜が短い日。本格的な夏の到来を告げます。' },
                { name: '小暑', date: new Date('2026-07-07T10:50:00'), season: 'summer', description: '暑さが本格的になる頃。梅雨明けが近づき、蝉が鳴き始めます。' },
                { name: '大暑', date: new Date('2026-07-23T04:07:00'), season: 'summer', description: '一年で最も暑さが厳しい時期。夏の土用の時期でもあります。' },
                { name: '立秋', date: new Date('2026-08-07T20:38:00'), season: 'autumn', description: '暦の上での秋の始まり。まだ暑いですが、朝夕は涼しくなり始めます。' },
                { name: '処暑', date: new Date('2026-08-23T11:16:00'), season: 'autumn', description: '暑さが和らぐ頃。朝晩の涼しさに秋の気配を感じ始めます。' },
                { name: '白露', date: new Date('2026-09-07T23:41:00'), season: 'autumn', description: '草花に朝露が宿り始める頃。日中は暖かくても朝晩は冷え込みます。' },
                { name: '秋分', date: new Date('2026-09-23T09:04:00'), season: 'autumn', description: '昼と夜の長さがほぼ等しくなる日。秋彼岸の中日でもあります。' },
                { name: '寒露', date: new Date('2026-10-08T15:31:00'), season: 'autumn', description: '露が冷たく感じられる頃。秋が深まり、紅葉が美しくなります。' },
                { name: '霜降', date: new Date('2026-10-23T18:38:00'), season: 'autumn', description: '露が霜に変わり始める頃。朝晩の冷え込みが厳しくなります。' },
                { name: '立冬', date: new Date('2026-11-07T18:54:00'), season: 'winter', description: '暦の上での冬の始まり。日差しが弱まり、冬の気配を感じ始めます。' },
                { name: '小雪', date: new Date('2026-11-22T16:24:00'), season: 'winter', description: '雪が降り始める頃。まだ積もるほどではない、わずかな雪を指します。' },
                { name: '大雪', date: new Date('2026-12-07T11:55:00'), season: 'winter', description: '本格的に雪が降り始める頃。山々は雪に覆われ、平地でも雪が降ります。' },
                { name: '冬至', date: new Date('2026-12-22T05:53:00'), season: 'winter', description: '一年で最も昼が短く夜が長い日。ゆず湯に入り、かぼちゃを食べる風習があります。' }
            ]
        };

        function createSeasonalAnimation(season) {
            const animationEl = document.getElementById('seasonAnimation');
            if (!animationEl) { console.error('Animation element not found'); return; }
            animationEl.innerHTML = '';
            let particleCount;
            let particleClass = '';
            
            switch(season) {
                case 'spring':
                    particleCount = window.innerWidth < 640 ? 15 : 30;
                    particleClass = 'sakura-petal';
                    break;
                case 'summer': // Sea bubbles
                    particleCount = window.innerWidth < 640 ? 20 : 40; // More bubbles
                    particleClass = 'sea-bubble';
                    break;
                case 'autumn':
                    particleCount = window.innerWidth < 640 ? 12 : 25;
                    particleClass = 'autumn-leaf';
                    break;
                case 'winter':
                    particleCount = window.innerWidth < 640 ? 10 : 20;
                    particleClass = 'snow-flake';
                    break;
                default:
                    particleCount = window.innerWidth < 640 ? 15 : 30;
                    particleClass = 'sakura-petal'; // Default to spring
            }
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = particleClass;
                const delay = Math.random() * (season === 'summer' ? 8 : 5); // Bubbles can have longer delay variation
                const startX = Math.random() * 100;
                particle.style.left = startX + '%';
                particle.style.animationDelay = delay + 's';

                if (season === 'spring') {
                    const sakuraDuration = 8 + Math.random() * 6;
                    particle.style.animationDuration = sakuraDuration + 's';
                    const sakuraSize = Math.random() * 0.5 + 0.5;
                    particle.style.transform = `scale(${sakuraSize}) rotate(-45deg)`;
                } else if (season === 'summer') {
                    const bubbleDuration = 5 + Math.random() * 8; // Bubbles rise at varying speeds
                    particle.style.animationDuration = bubbleDuration + 's';
                    const bubbleSize = (Math.random() * 15 + 5) + 'px'; // Bubbles of 5px to 20px
                    particle.style.width = bubbleSize;
                    particle.style.height = bubbleSize;
                     // Random horizontal start offset for bubbles to not all come from same X point at bottom
                    particle.style.left = (Math.random() * 90 + 5) + '%'; // From 5% to 95% of width
                } else if (season === 'autumn') {
                    const autumnDuration = 7 + Math.random() * 5;
                    particle.style.animationDuration = autumnDuration + 's';
                    const autumnSize = Math.random() * 0.6 + 0.4;
                    particle.style.transform = `scale(${autumnSize})`;
                } else if (season === 'winter') {
                    const winterDuration = 10 + Math.random() * 5;
                    particle.style.animationDuration = winterDuration + 's';
                    // particle.style.width = (10 + Math.random() * 10) + 'px'; // Example size variation
                    // particle.style.height = particle.style.width;
                }
                animationEl.appendChild(particle);
            }
        }

        function createRipple(e) {
            const button = e.currentTarget;
            if (button.disabled) return;
            const ripple = document.createElement('span');
            const rect = button.getBoundingClientRect();
            const size = Math.max(rect.width, rect.height);
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const x = clientX - rect.left - size / 2;
            const y = clientY - rect.top - size / 2;
            ripple.style.width = ripple.style.height = size + 'px';
            ripple.style.left = x + 'px';
            ripple.style.top = y + 'px';
            ripple.classList.add('ripple');
            const existingRipple = button.querySelector('.ripple');
            if (existingRipple) { existingRipple.remove(); }
            button.appendChild(ripple);
            setTimeout(() => ripple.remove(), 1000);
        }

        const app = {
            tasks: [],
            deadlineTasks: [],
            inboxItems: [],
            selectedDate: new Date(),
            taskType: 'normal',
            totalPoints: 0,
            dailyPointHistory: {},
            dailyReflections: {},
            openaiApiKey: null,

            init() {
                this.loadData();
                this.bindEvents();
                this.updateSekki(); 
            },

            updateSekki() { /* Same as before */
                const now = new Date();
                const year = now.getFullYear();
                const currentYearSekki = sekkiData[year] || [];
                const nextYearSekki = sekkiData[year + 1] || [];
                const allSekki = [...currentYearSekki, ...nextYearSekki];
                let currentSekki = null;
                let nextSekki = null;
                for (let i = 0; i < allSekki.length; i++) {
                    if (now >= allSekki[i].date) { currentSekki = allSekki[i]; } 
                    else { nextSekki = allSekki[i]; break; }
                }
                if (!currentSekki && allSekki.length > 0) {
                    currentSekki = allSekki.find(s => now < s.date) || allSekki[allSekki.length -1]; 
                    if (!currentSekki && sekkiData[year-1] && sekkiData[year-1].length > 0) { 
                        currentSekki = sekkiData[year-1][sekkiData[year-1].length -1];
                    }
                }
                if (currentSekki) {
                    document.getElementById('currentSekki').textContent = currentSekki.name;
                    const dateStr = currentSekki.date.toLocaleDateString('ja-JP', { month: 'long', day: 'numeric' });
                    document.getElementById('sekkiDate').textContent = `${dateStr}より`;
                    const actualSeason = getActualSeason(now); 
                    const bg = document.getElementById('backgroundSeason');
                    bg.className = bg.className.replace(/bg-(spring|summer|autumn|winter)/g, '');
                    bg.classList.add(`bg-${actualSeason}`);
                    createSeasonalAnimation(actualSeason); 
                    this.showSekkiDetail(currentSekki);
                }
                if (nextSekki) {
                    const daysUntil = Math.ceil((nextSekki.date - now) / (1000 * 60 * 60 * 24));
                    document.getElementById('nextSekkiInfo').textContent = `次は「${nextSekki.name}」 あと${daysUntil}日`;
                } else {
                     document.getElementById('nextSekkiInfo').textContent = `次の節気情報は翌年になります`;
                }
                this.updateYearSekkiList();
                this.render();
             },
            
            updateYearSekkiList() { /* Same as before */
                const year = this.selectedDate.getFullYear(); 
                const yearSekki = sekkiData[year] || [];
                const listEl = document.getElementById('yearSekkiList');
                listEl.innerHTML = '';
                yearSekki.forEach(sekki => {
                    const itemEl = document.createElement('div');
                    const isPast = new Date() > sekki.date && !this.isCurrentSekki(sekki, this.selectedDate); 
                    const isCurrentlyDisplayedSekki = this.isCurrentSekki(sekki, this.selectedDate); 
                    itemEl.className = `p-1.5 sm:p-2 rounded text-center transition-all cursor-pointer ${
                        isCurrentlyDisplayedSekki ? 'bg-gray-800 text-white' : 
                        isPast ? 'text-gray-400' : 'text-gray-700 hover:bg-gray-100'
                    }`;
                    itemEl.innerHTML = `
                        <div class="font-medium text-xs sm:text-sm">${sekki.name}</div>
                        <div class="text-xs ${isCurrentlyDisplayedSekki ? 'text-gray-300' : 'text-gray-500'}">
                            ${sekki.date.getMonth() + 1}/${sekki.date.getDate()}
                        </div>`;
                    itemEl.addEventListener('click', () => {
                        this.showSekkiDetail(sekki); 
                        this.updateYearSekkiList(); 
                    });
                    listEl.appendChild(itemEl);
                });},
            
            showSekkiDetail(sekki) { /* Same as before */
                document.getElementById('sekkiDetailName').textContent = sekki.name;
                document.getElementById('sekkiDetailDate').textContent = sekki.date.toLocaleDateString('ja-JP', { 
                    year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric'
                });
                document.getElementById('sekkiDescription').textContent = sekki.description;
                const sekkiEffectiveSeason = getActualSeason(sekki.date);
                const bg = document.getElementById('backgroundSeason');
                bg.className = bg.className.replace(/bg-(spring|summer|autumn|winter)/g, '');
                bg.classList.add(`bg-${sekkiEffectiveSeason}`);
                createSeasonalAnimation(sekkiEffectiveSeason);},
            
            isCurrentSekki(sekkiToCheck, referenceDate) { /* Same as before */
                const year = referenceDate.getFullYear();
                const allSekkiForYear = sekkiData[year] || [];
                const allSekkiForPrevYear = sekkiData[year-1] || [];
                const relevantSekki = [...allSekkiForPrevYear.slice(-1), ...allSekkiForYear];
                for (let i = 0; i < relevantSekki.length; i++) {
                    const currentS = relevantSekki[i];
                    const nextS = relevantSekki[i + 1];
                    if (referenceDate >= currentS.date) {
                        if (nextS && referenceDate < nextS.date) {
                            return sekkiToCheck.name === currentS.name && sekkiToCheck.date.getTime() === currentS.date.getTime();
                        } else if (!nextS) { 
                            return sekkiToCheck.name === currentS.name && sekkiToCheck.date.getTime() === currentS.date.getTime();
                        }
                    }
                }
                return false;},
            
            updateCalendarSekkiInfo() { /* Same as before */
                const dateInput = document.getElementById('dateInput');
                if (!dateInput.value) return; 
                const selectedDate = new Date(dateInput.value);
                if (isNaN(selectedDate.getTime())) return; 
                const year = selectedDate.getFullYear();
                const sekkiList = [...(sekkiData[year - 1] || []), ...(sekkiData[year] || []), ...(sekkiData[year + 1] || [])].filter(s => s); 
                if (sekkiList.length === 0) {
                     document.getElementById('calendarSekkiInfo').classList.add('hidden');
                     return;
                }
                let currentSekkiForDate = null;
                for (let i = 0; i < sekkiList.length; i++) {
                    if (selectedDate >= sekkiList[i].date) {
                        currentSekkiForDate = sekkiList[i];
                    } else {
                        if (!currentSekkiForDate) currentSekkiForDate = sekkiList[i]; 
                        break;
                    }
                }
                const infoEl = document.getElementById('calendarSekkiInfo');
                if (currentSekkiForDate) {
                    let message = `選択日は「${currentSekkiForDate.name}」の期間です。`;
                    if (selectedDate.toDateString() === currentSekkiForDate.date.toDateString()){
                        message = `この日は「${currentSekkiForDate.name}」です。`;
                    } else {
                        const currentIndexInYear = (sekkiData[currentSekkiForDate.date.getFullYear()] || []).findIndex(s => s.name === currentSekkiForDate.name);
                        const yearSekki = sekkiData[currentSekkiForDate.date.getFullYear()] || [];
                        if (selectedDate < currentSekkiForDate.date && currentIndexInYear > 0) {
                            const prevSekki = yearSekki[currentIndexInYear -1];
                            message = `「${prevSekki.name}」の期間、次の節気は「${currentSekkiForDate.name}」です。`;
                        } else if (selectedDate > currentSekkiForDate.date) {
                            const nextSekkiInList = yearSekki[currentIndexInYear + 1];
                            if (nextSekkiInList && selectedDate >= nextSekkiInList.date) {
                                message = `選択日は「${nextSekkiInList.name}」の期間です。`;
                            } else {
                                message = `「${currentSekkiForDate.name}」の期間です。`;
                            }
                        }
                    }
                    infoEl.textContent = message;
                    infoEl.classList.remove('hidden');
                } else {
                    infoEl.classList.add('hidden');
                }
            },

            loadData() { /* Same as before */
                const saved = localStorage.getItem('focusTaskData');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.tasks = (data.tasks || []).map(t => ({ ...t, createdAt: new Date(t.createdAt), completedAt: t.completedAt ? new Date(t.completedAt) : null, scheduledFor: new Date(t.scheduledFor), points: t.points || 0 }));
                    this.deadlineTasks = (data.deadlineTasks || []).map(t => ({ ...t, deadline: new Date(t.deadline), createdAt: new Date(t.createdAt), completedAt: t.completedAt ? new Date(t.completedAt) : null }));
                    this.inboxItems = data.inboxItems || [];
                    this.totalPoints = data.totalPoints || 0;
                    this.dailyPointHistory = data.dailyPointHistory || {};
                    this.dailyReflections = data.dailyReflections || {};
                    this.openaiApiKey = data.openaiApiKey || null;
                }},

            saveData() { /* Same as before */
                localStorage.setItem('focusTaskData', JSON.stringify({ 
                    tasks: this.tasks, 
                    deadlineTasks: this.deadlineTasks, 
                    inboxItems: this.inboxItems, 
                    totalPoints: this.totalPoints, 
                    dailyPointHistory: this.dailyPointHistory,
                    dailyReflections: this.dailyReflections,
                    openaiApiKey: this.openaiApiKey
                }));},

            bindEvents() { 
                document.getElementById('prevDay').addEventListener('click', () => this.navigateDate(-1));
                document.getElementById('nextDay').addEventListener('click', () => this.navigateDate(1));
                document.getElementById('todayButton').addEventListener('click', () => this.goToToday());
                document.getElementById('calendarToggle').addEventListener('click', () => this.toggleCalendar());
                const dateInputElement = document.getElementById('dateInput');
                dateInputElement.addEventListener('change', (e) => this.selectDate(e.target.value));
                dateInputElement.addEventListener('input', () => this.updateCalendarSekkiInfo()); 
                document.getElementById('normalType').addEventListener('click', () => this.setTaskType('normal'));
                document.getElementById('urgentType').addEventListener('click', () => this.setTaskType('urgent'));
                document.getElementById('addTask').addEventListener('click', () => this.showPointSelector());
                document.getElementById('taskInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') this.showPointSelector(); });
                document.querySelectorAll('.point-button').forEach(btn => {
                    btn.addEventListener('click', (e) => this.selectPoints(e.target.dataset.points));
                });
                document.getElementById('confirmAddTask').addEventListener('click', () => this.addTask());
                document.getElementById('deadlineToggle').addEventListener('click', () => this.toggleDeadlineForm());
                document.getElementById('addDeadline').addEventListener('click', () => this.addDeadlineTask());
                document.getElementById('cancelDeadline').addEventListener('click', () => this.toggleDeadlineForm(false)); 
                document.getElementById('inboxToggle').addEventListener('click', () => this.toggleInbox());
                document.getElementById('addInbox').addEventListener('click', () => this.addInboxItem());
                document.getElementById('inboxInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') this.addInboxItem(); });
                document.getElementById('statsToggle').addEventListener('click', () => this.toggleStats());
                document.getElementById('resetStats').addEventListener('click', () => this.resetStats());
                document.getElementById('reflectionToggle').addEventListener('click', () => this.toggleReflection());
                document.getElementById('saveReflection').addEventListener('click', () => this.saveReflection());
                document.getElementById('cancelReflection').addEventListener('click', () => this.toggleReflection(false));
                document.getElementById('reflectionInput').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.ctrlKey) this.saveReflection();
                });
                document.getElementById('aiSettingsToggle').addEventListener('click', () => this.toggleApiKeyForm());
                document.getElementById('saveApiKey').addEventListener('click', () => this.saveApiKey());
                document.getElementById('cancelApiKey').addEventListener('click', () => this.toggleApiKeyForm(false));
                document.querySelectorAll('.ai-period-button').forEach(btn => {
                    btn.addEventListener('click', (e) => this.generateAIComment(e.target.dataset.period));
                });

                // --- NEW: スワイプによる日付移動機能 ---
                const swipeArea = document.body;
                let touchStartX = 0;
                let touchStartY = 0;
                let isSwipeActive = false; // スワイプ操作中かどうかのフラグ

                swipeArea.addEventListener('touchstart', (e) => {
                    // ボタンや入力、特定の操作エリアではスワイプを開始しない
                    if (e.target.closest('button, input, a, .sekki-grid')) {
                        isSwipeActive = false;
                        return;
                    }
                    isSwipeActive = true;
                    touchStartX = e.changedTouches[0].screenX;
                    touchStartY = e.changedTouches[0].screenY;
                }, { passive: true });

                swipeArea.addEventListener('touchend', (e) => {
                    if (!isSwipeActive) return;
                    isSwipeActive = false; // フラグをリセット

                    const touchEndX = e.changedTouches[0].screenX;
                    const touchEndY = e.changedTouches[0].screenY;
                    this.handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
                }, { passive: true });
            },
            
            // --- NEW: スワイプ操作を処理するメソッド ---
            handleSwipe(startX, startY, endX, endY) {
                const thresholdX = 50;  // 横スワイプとして認識する最小距離
                const restraintY = 100; // 横スワイプ中に許容される縦の最大移動距離

                const diffX = endX - startX;
                const diffY = endY - startY;

                // 横方向の移動がしきい値を超え、縦方向の移動が抑制範囲内かをチェック
                if (Math.abs(diffX) > thresholdX && Math.abs(diffY) < restraintY) {
                    if (diffX > 0) {
                        this.navigateDate(-1); // 右スワイプで前の日へ
                    } else {
                        this.navigateDate(1);  // 左スワイプで次の日へ
                    }
                }
            },

            navigateDate(days) { /* Same as before */
                const newDate = new Date(this.selectedDate);
                newDate.setDate(newDate.getDate() + days);
                this.selectedDate = newDate;
                this.updateSekkiForSelectedDate(); 
                this.render();},

            goToToday() { /* Same as before */
                this.selectedDate = new Date();
                this.updateSekkiForSelectedDate();
                this.render();},

            selectDate(dateStr) { /* Same as before */
                const newDate = new Date(dateStr);
                if (!isNaN(newDate.getTime())) {
                    this.selectedDate = newDate;
                    document.getElementById('calendarInput').classList.add('hidden');
                    this.updateCalendarSekkiInfo(); 
                    this.updateSekkiForSelectedDate(); 
                    this.render();
                } else {
                    this.showError("無効な日付形式です。");
                }},
            updateSekkiForSelectedDate() { /* Same as before */
                const year = this.selectedDate.getFullYear();
                const allSekki = [...(sekkiData[year] || []), ...(sekkiData[year + 1] || [])];
                let currentSekkiForDisplay = null;
                let nextSekkiForDisplay = null;
                for (let i = 0; i < allSekki.length; i++) {
                    if (this.selectedDate >= allSekki[i].date) { currentSekkiForDisplay = allSekki[i];} 
                    else { nextSekkiForDisplay = allSekki[i]; break; }
                }
                if (!currentSekkiForDisplay && allSekki.length > 0) {
                    const prevYearSekki = sekkiData[year - 1] || [];
                    if (prevYearSekki.length > 0) { currentSekkiForDisplay = prevYearSekki[prevYearSekki.length -1]; } 
                    else { currentSekkiForDisplay = allSekki[0]; }
                }
                if (currentSekkiForDisplay) {
                    document.getElementById('currentSekki').textContent = currentSekkiForDisplay.name;
                    const dateStr = currentSekkiForDisplay.date.toLocaleDateString('ja-JP', { month: 'long', day: 'numeric' });
                    document.getElementById('sekkiDate').textContent = `${dateStr}より`;
                    const actualSeasonOfSelectedDate = getActualSeason(this.selectedDate);
                    const bg = document.getElementById('backgroundSeason');
                    bg.className = bg.className.replace(/bg-(spring|summer|autumn|winter)/g, '');
                    bg.classList.add(`bg-${actualSeasonOfSelectedDate}`);
                    createSeasonalAnimation(actualSeasonOfSelectedDate);
                    this.showSekkiDetail(currentSekkiForDisplay);
                }
                if (nextSekkiForDisplay) {
                    const daysUntil = Math.ceil((nextSekkiForDisplay.date - this.selectedDate) / (1000 * 60 * 60 * 24));
                    document.getElementById('nextSekkiInfo').textContent = `次は「${nextSekkiForDisplay.name}」 あと${daysUntil > 0 ? daysUntil : 0}日`;
                } else {
                     document.getElementById('nextSekkiInfo').textContent = `次の節気情報は翌年になります`;
                }
                this.updateYearSekkiList();},

            toggleCalendar() { /* Same as before */
                const inputContainer = document.getElementById('calendarInput');
                const dateInputEl = document.getElementById('dateInput');
                inputContainer.classList.toggle('hidden');
                if (!inputContainer.classList.contains('hidden')) {
                    dateInputEl.value = this.selectedDate.toISOString().split('T')[0];
                    this.updateCalendarSekkiInfo(); 
                    dateInputEl.focus(); 
                }},

            setTaskType(type) { /* Same as before */
                this.taskType = type;
                const normalButton = document.getElementById('normalType');
                const urgentButton = document.getElementById('urgentType');
                normalButton.className = `flex-1 px-4 py-2 rounded-full font-medium transition-all button-large ${ type === 'normal' ? 'bg-gray-800 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200' }`;
                urgentButton.className = `flex-1 px-4 py-2 rounded-full font-medium transition-all button-large ${ type === 'urgent' ? 'bg-gray-800 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200' }`;},

            selectedPoints: 0,
            
            showPointSelector() {
                const input = document.getElementById('taskInput');
                const text = input.value.trim();
                if (!text) { this.showError('予定を入力してください'); return; }
                
                if (this.taskType === 'urgent') {
                    document.getElementById('pointSelector').classList.remove('hidden');
                    document.getElementById('addTask').classList.add('hidden');
                    this.selectedPoints = 0;
                    document.querySelectorAll('.point-button').forEach(btn => {
                        btn.classList.remove('bg-gray-800', 'text-white');
                        btn.classList.add('bg-gray-200', 'text-gray-700');
                    });
                } else {
                    this.selectedPoints = 0;
                    this.addTask();
                }
            },
            
            selectPoints(points) {
                this.selectedPoints = parseInt(points);
                document.querySelectorAll('.point-button').forEach(btn => {
                    if (btn.dataset.points === points) {
                        btn.classList.add('bg-gray-800', 'text-white');
                        btn.classList.remove('bg-gray-200', 'text-gray-700');
                    } else {
                        btn.classList.remove('bg-gray-800', 'text-white');
                        btn.classList.add('bg-gray-200', 'text-gray-700');
                    }
                });
            },
            
            addTask() { /* Same as before */
                const input = document.getElementById('taskInput');
                const text = input.value.trim();
                if (!text) { this.showError('予定を入力してください'); return; }
                
                if (this.taskType === 'urgent' && this.selectedPoints === 0) {
                    this.showError('目標タスクにはポイントを設定してください');
                    return;
                }
                
                const todayTasks = this.getTodayTasks();
                const normalCount = todayTasks.filter(t => t.type === 'normal' && !t.isCompleted).length; 
                const urgentCount = todayTasks.filter(t => t.type === 'urgent' && !t.isCompleted).length; 
                if (this.taskType === 'normal' && normalCount >= 3) { this.showError('通常タスクは3件までです（未完了）'); return; }
                if (this.taskType === 'urgent' && urgentCount >= 3) { this.showError('目標タスクは3件までです（未完了）'); return; }
                const newTask = { id: Date.now().toString(), text: text, type: this.taskType, points: this.taskType === 'urgent' ? this.selectedPoints : 0, createdAt: new Date(), completedAt: null, isCompleted: false, scheduledFor: new Date(this.selectedDate) };
                this.tasks.push(newTask);
                input.value = '';
                
                document.getElementById('pointSelector').classList.add('hidden');
                document.getElementById('addTask').classList.remove('hidden');
                this.selectedPoints = 0;
                
                this.saveData();
                this.render();},

            toggleTask(taskId) { /* Same as before */
                const task = this.tasks.find(t => t.id === taskId);
                if (!task) return;
                if (!task.isCompleted) { 
                    this.showCelebration();
                    if (task.type === 'urgent' && task.points > 0) {
                        this.totalPoints += task.points;
                        const today = new Date().toDateString();
                        if (!this.dailyPointHistory[today]) {
                            this.dailyPointHistory[today] = 0;
                        }
                        this.dailyPointHistory[today] += task.points;
                    }
                } else {
                    if (task.type === 'urgent' && task.points > 0) {
                        this.totalPoints -= task.points;
                        const today = new Date().toDateString();
                        if (this.dailyPointHistory[today]) {
                            this.dailyPointHistory[today] -= task.points;
                        }
                    }
                }
                task.isCompleted = !task.isCompleted;
                task.completedAt = task.isCompleted ? new Date() : null;
                this.saveData();
                this.render();},

            postponeTask(taskId) { /* Same as before */
                const task = this.tasks.find(t => t.id === taskId);
                if (!task) return;
                const tomorrow = new Date(this.selectedDate);
                tomorrow.setDate(tomorrow.getDate() + 1);
                const tomorrowTasks = this.tasks.filter(t => new Date(t.scheduledFor).toDateString() === tomorrow.toDateString() && !t.isCompleted );
                const normalCount = tomorrowTasks.filter(t => t.type === 'normal').length;
                const urgentCount = tomorrowTasks.filter(t => t.type === 'urgent').length;
                if (task.type === 'normal' && normalCount >= 3) { this.showError('翌日の通常タスクは既に3件です（未完了）'); return; }
                if (task.type === 'urgent' && urgentCount >= 3) { this.showError('翌日の目標タスクは既に3件です（未完了）'); return; }
                task.scheduledFor = tomorrow;
                this.showPostponeEffect();
                setTimeout(() => { this.saveData(); this.render(); }, 600);},

            deleteTask(taskId) { /* Same as before */
                this.tasks = this.tasks.filter(t => t.id !== taskId);
                this.saveData();
                this.render();},

            toggleDeadlineForm(forceHide = null) { /* Same as before */
                const form = document.getElementById('deadlineForm');
                const activeCount = this.deadlineTasks.filter(t => !t.isCompleted).length;
                if (forceHide === false) { form.classList.add('hidden'); return; }
                if (forceHide === true) { if (activeCount < 3) form.classList.remove('hidden'); else this.showError('期限付きタスクは3件までです'); return; }
                if (form.classList.contains('hidden')) { 
                    if (activeCount >= 3) { this.showError('期限付きタスクは3件までです'); return; }
                    form.classList.remove('hidden');
                    document.getElementById('deadlineDate').min = new Date().toISOString().split('T')[0];
                    document.getElementById('deadlineText').focus();
                } else { 
                    form.classList.add('hidden');
                }},

            addDeadlineTask() { /* Same as before */
                const textEl = document.getElementById('deadlineText');
                const dateEl = document.getElementById('deadlineDate');
                const text = textEl.value.trim();
                const date = dateEl.value;
                if (!text || !date) { this.showError('内容と期限を入力してください'); return; }
                const activeCount = this.deadlineTasks.filter(t => !t.isCompleted).length;
                if (activeCount >= 3) { this.showError('期限付きタスクは3件までです'); return; }
                const newTask = { id: Date.now().toString(), text: text, deadline: new Date(date + "T23:59:59"), createdAt: new Date(), isCompleted: false, completedAt: null };
                this.deadlineTasks.push(newTask);
                textEl.value = ''; dateEl.value = '';
                this.toggleDeadlineForm(false); 
                this.saveData(); this.render();},

            toggleDeadlineTask(taskId) { /* Same as before */
                const task = this.deadlineTasks.find(t => t.id === taskId);
                if (!task) return;
                if (!task.isCompleted) { this.showCelebration(); }
                task.isCompleted = !task.isCompleted;
                task.completedAt = task.isCompleted ? new Date() : null;
                this.saveData();
                this.render();},
            
            // --- NEW: Delete Deadline Task ---
            deleteDeadlineTask(taskId) {
                this.deadlineTasks = this.deadlineTasks.filter(t => t.id !== taskId);
                this.saveData();
                this.render();
            },

            toggleInbox() { /* Same as before */
                const inboxSection = document.getElementById('inboxSection');
                inboxSection.classList.toggle('hidden');
                if(!inboxSection.classList.contains('hidden')) { document.getElementById('inboxInput').focus(); }},

            addInboxItem() { /* Same as before */
                const input = document.getElementById('inboxInput');
                const text = input.value.trim();
                if (!text) return;
                this.inboxItems.push({ id: Date.now().toString(), text: text });
                input.value = ''; this.saveData(); this.render(); },
            
            deleteInboxItem(itemId) { /* Same as before */
                this.inboxItems = this.inboxItems.filter(item => item.id !== itemId);
                this.saveData(); this.render();},

            getTodayTasks() { /* Same as before */
                const dateStr = this.selectedDate.toDateString();
                return this.tasks.filter(t => new Date(t.scheduledFor).toDateString() === dateStr);},

            getDaysUntilDeadline(deadline) { /* Same as before */
                const today = new Date(); today.setHours(0, 0, 0, 0); 
                const deadlineDate = new Date(deadline); deadlineDate.setHours(0, 0, 0, 0);
                const diffTime = deadlineDate - today;
                return Math.ceil(diffTime / (1000 * 60 * 60 * 24));},

            formatDate(date) { /* Same as before */
                const today = new Date(); today.setHours(0,0,0,0);
                const compDate = new Date(date); compDate.setHours(0,0,0,0);
                if (compDate.toDateString() === today.toDateString()) return '本日';
                const tomorrow = new Date(today); tomorrow.setDate(today.getDate() + 1);
                if (compDate.toDateString() === tomorrow.toDateString()) return '明日';
                const yesterday = new Date(today); yesterday.setDate(today.getDate() - 1);
                if (compDate.toDateString() === yesterday.toDateString()) return '昨日';
                const weekdays = ['日', '月', '火', '水', '木', '金', '土'];
                return `${compDate.getMonth() + 1}月${compDate.getDate()}日(${weekdays[compDate.getDay()]})`;},

            showError(message) { /* Same as before */
                const elem = document.getElementById('errorMessage');
                elem.textContent = message; elem.classList.remove('hidden');
                setTimeout(() => elem.classList.add('hidden'), 3000);},

            showCelebration() { /* Same as before */
                const elem = document.getElementById('celebration');
                elem.classList.remove('hidden');
                setTimeout(() => elem.classList.add('hidden'), 1500);},

            showPostponeEffect() { /* Same as before */
                const elem = document.getElementById('postponeEffect');
                elem.classList.remove('hidden');
                setTimeout(() => elem.classList.add('hidden'), 1500);},

            toggleStats() {
                const statsSection = document.getElementById('statsSection');
                statsSection.classList.toggle('hidden');
                if (!statsSection.classList.contains('hidden')) {
                    this.renderWeeklyStats();
                }
            },
            
            renderWeeklyStats() {
                const weeklyStatsEl = document.getElementById('weeklyStats');
                weeklyStatsEl.innerHTML = '';
                
                const today = new Date();
                for (let i = 6; i >= 0; i--) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    const dateStr = date.toDateString();
                    const points = this.dailyPointHistory[dateStr] || 0;
                    const dayName = i === 0 ? '今日' : i === 1 ? '昨日' : date.toLocaleDateString('ja-JP', { month: 'numeric', day: 'numeric' });
                    
                    const dayEl = document.createElement('div');
                    dayEl.className = 'flex items-center justify-between p-2 rounded-lg ' + (i === 0 ? 'bg-amber-50' : 'bg-gray-50');
                    dayEl.innerHTML = `
                        <span class="text-sm text-gray-700">${dayName}</span>
                        <div class="flex items-center gap-2">
                            <div class="h-2 bg-gray-200 rounded-full" style="width: 100px;">
                                <div class="h-full bg-amber-500 rounded-full transition-all" style="width: ${Math.min(points * 10, 100)}%;"></div>
                            </div>
                            <span class="text-sm font-medium text-gray-700 w-12 text-right">${points}pt</span>
                        </div>
                    `;
                    weeklyStatsEl.appendChild(dayEl);
                }
            },
            
            resetStats() {
                if (confirm('すべてのポイント統計をリセットしますか？')) {
                    this.totalPoints = 0;
                    this.dailyPointHistory = {};
                    this.saveData();
                    this.render();
                    this.renderWeeklyStats();
                }
            },
            
            toggleReflection(forceHide = null) {
                const form = document.getElementById('reflectionForm');
                const toggle = document.getElementById('reflectionToggle');
                
                if (forceHide === false) {
                    form.classList.add('hidden');
                    return;
                }
                
                form.classList.toggle('hidden');
                if (!form.classList.contains('hidden')) {
                    const dateStr = this.selectedDate.toDateString();
                    const reflection = this.dailyReflections[dateStr] || '';
                    document.getElementById('reflectionInput').value = reflection;
                    document.getElementById('reflectionInput').focus();
                }
            },
            
            saveReflection() {
                const input = document.getElementById('reflectionInput');
                const text = input.value.trim();
                const dateStr = this.selectedDate.toDateString();
                
                if (text) {
                    this.dailyReflections[dateStr] = text;
                } else {
                    delete this.dailyReflections[dateStr];
                }
                
                this.saveData();
                this.toggleReflection(false);
                this.render();
            },
            
            toggleApiKeyForm(forceHide = null) {
                const form = document.getElementById('apiKeyForm');
                
                if (forceHide === false) {
                    form.classList.add('hidden');
                    return;
                }
                
                form.classList.toggle('hidden');
                if (!form.classList.contains('hidden')) {
                    document.getElementById('apiKeyInput').value = this.openaiApiKey || '';
                    document.getElementById('apiKeyInput').focus();
                }
            },
            
            saveApiKey() {
                const input = document.getElementById('apiKeyInput');
                const key = input.value.trim();
                
                if (key) {
                    this.openaiApiKey = key;
                } else {
                    this.openaiApiKey = null;
                }
                
                this.saveData();
                this.toggleApiKeyForm(false);
                this.render();
            },
            
            async generateAIComment(period) {
                if (!this.openaiApiKey) {
                    this.showError('APIキーを設定してください');
                    return;
                }
                
                const periodNames = {
                    daily: 'デイリー',
                    weekly: '週間',
                    sekki: '節気間',
                    monthly: '月間',
                    quarterly: '3ヶ月'
                };
                
                if (!confirm(`${periodNames[period]}のAIコメントを生成しますか？`)) {
                    return;
                }
                
                const loading = document.getElementById('aiCommentLoading');
                const content = document.getElementById('aiCommentContent');
                const noApiKey = document.getElementById('noApiKey');
                
                loading.classList.remove('hidden');
                content.classList.add('hidden');
                noApiKey.classList.add('hidden');
                
                try {
                    const prompt = this.buildAIPrompt(period);
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.openaiApiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-3.5-turbo',
                            messages: [{
                                role: 'system',
                                content: 'You are a supportive coach for someone with ADHD tendencies. Provide encouraging, practical advice while being understanding of ADHD challenges. Write in Japanese. IMPORTANT: Always complete your sentences and thoughts. Never cut off mid-sentence. Ensure your response is a complete, coherent message.'
                            }, {
                                role: 'user',
                                content: prompt
                            }],
                            temperature: 0.7,
                            max_tokens: period === 'quarterly' ? 3000 : period === 'monthly' ? 1500 : period === 'sekki' ? 1200 : period === 'weekly' ? 900 : 600
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('APIリクエストが失敗しました');
                    }
                    
                    const data = await response.json();
                    const message = data.choices[0].message.content;
                    
                    content.textContent = message;
                    content.classList.remove('hidden');
                    loading.classList.add('hidden');
                    
                    // ボタンのハイライト
                    document.querySelectorAll('.ai-period-button').forEach(btn => {
                        if (btn.dataset.period === period) {
                            btn.classList.add('bg-gray-800', 'text-white');
                            btn.classList.remove('bg-gray-200', 'text-gray-700');
                        } else {
                            btn.classList.remove('bg-gray-800', 'text-white');
                            btn.classList.add('bg-gray-200', 'text-gray-700');
                        }
                    });
                    
                } catch (error) {
                    console.error('AI comment generation failed:', error);
                    this.showError('AIコメントの生成に失敗しました');
                    loading.classList.add('hidden');
                    noApiKey.classList.remove('hidden');
                }
            },
            
            buildAIPrompt(period) {
                const now = new Date();
                const stats = this.gatherStatsForPeriod(period);
                const currentSekki = document.getElementById('currentSekki').textContent;
                const season = getActualSeason(now);
                
                let prompt = `現在は${currentSekki}の時期で、${season === 'spring' ? '春' : season === 'summer' ? '夏' : season === 'autumn' ? '秋' : '冬'}です。\n\n`;
                
                switch(period) {
                    case 'daily':
                        prompt += `今日のタスク実績:\n`;
                        prompt += `- 通常タスク: ${stats.normalCompleted}/${stats.normalTotal}完了\n`;
                        prompt += `- 目標タスク: ${stats.goalCompleted}/${stats.goalTotal}完了 (獲得ポイント: ${stats.pointsToday}pt)\n`;
                        if (stats.todayReflection) {
                            prompt += `振り返り: ${stats.todayReflection}\n`;
                        }
                        if (stats.daysToNextSekki <= 3) {
                            prompt += `※${stats.daysToNextSekki}日後に${stats.nextSekkiName}に変わります\n`;
                        }
                        prompt += `\nADHD傾向がある私に、今日の振り返りと明日へのアドバイスを400文字程度でお願いします。${stats.daysToNextSekki <= 3 ? '節気の変わり目を意識したアドバイスも含めてください。' : ''}必ず最後まで完結した文章でお願いします。`;
                        break;
                        
                    case 'weekly':
                        prompt += `今週のタスク実績:\n`;
                        prompt += `- 通常タスク: ${stats.normalCompleted}/${stats.normalTotal}完了\n`;
                        prompt += `- 目標タスク: ${stats.goalCompleted}/${stats.goalTotal}完了\n`;
                        prompt += `- 獲得ポイント: ${stats.totalPoints}pt\n`;
                        prompt += `- 期限付きタスク: ${stats.deadlineCompleted}完了\n`;
                        if (stats.weeklyReflections && stats.weeklyReflections.length > 0) {
                            prompt += `今週の振り返りテーマ: ${stats.weeklyReflections.join('、')}\n`;
                        }
                        prompt += `\nADHD傾向がある私に、今週の振り返りと来週へのアドバイスを600文字程度でお願いします。現在の${currentSekki}の季節感を意識したアドバイスを含めてください。必ず最後まで完結した文章でお願いします。`;
                        break;
                        
                    case 'sekki':
                        prompt += `${currentSekki}期間（${stats.sekkiStartDate}〜現在）のタスク実績:\n`;
                        prompt += `- 実施日数: ${stats.activeDays}日\n`;
                        prompt += `- 総ポイント: ${stats.totalPoints}pt\n`;
                        prompt += `- 平均完了率: ${stats.avgCompletionRate}%\n`;
                        prompt += `- 最も達成した目標タイプ: ${stats.topGoalTheme || 'まだデータがありません'}\n`;
                        prompt += `\n${currentSekki}という節気の特徴と季節の変化を踏まえて、ADHD傾向がある私に季節に合わせた生活のアドバイスを800文字程度でお願いします。節気の意味や季節の風物詩、体調管理のポイントなども含めてください。必ず最後まで完結した文章でお願いします。`;
                        break;
                        
                    case 'monthly':
                        prompt += `今月のタスク実績:\n`;
                        prompt += `- 実施日数: ${stats.activeDays}日\n`;
                        prompt += `- 総ポイント: ${stats.totalPoints}pt\n`;
                        prompt += `- 目標達成率: ${stats.goalCompletionRate}%\n`;
                        prompt += `- 最も多かった振り返りテーマ: ${stats.commonReflectionTheme || '特になし'}\n`;
                        prompt += `- 今月含まれる節気: ${stats.monthSekki.join('、')}\n`;
                        prompt += `\nADHD傾向がある私に、今月の総括と来月の目標設定についてアドバイスを1000文字程度でお願いします。今月通過した節気の変化も踏まえた分析を含めてください。必ず最後まで完結した文章でお願いします。`;
                        break;
                        
                    case 'quarterly':
                        prompt += `過去3ヶ月のタスク実績:\n`;
                        prompt += `- 実施日数: ${stats.activeDays}日\n`;
                        prompt += `- 総ポイント: ${stats.totalPoints}pt\n`;
                        prompt += `- 平均ポイント/日: ${stats.avgPointsPerDay}pt\n`;
                        prompt += `- 最高連続日数: ${stats.maxStreak}日\n`;
                        prompt += `- 成長傾向: ${stats.growthTrend}\n`;
                        prompt += `- 3ヶ月間に経験した節気: ${stats.quarterSekki.join('、')}\n`;
                        prompt += `- 季節の変化: ${stats.seasonalTransition}\n`;
                        prompt += `\nADHD傾向がある私に、3ヶ月間の成長と今後の長期目標についてアドバイスを2000文字程度でお願いします。季節の移り変わりとともにどのような変化があったか、季節ごとのアドバイスも含めてください。必ず最後まで完結した文章でお願いします。`;
                        break;
                }
                
                return prompt;
            },
            
            gatherStatsForPeriod(period) {
                const now = new Date();
                const stats = {};
                
                // 次の節気までの日数を計算
                const year = now.getFullYear();
                const allSekki = [...(sekkiData[year] || []), ...(sekkiData[year + 1] || [])];
                let nextSekki = null;
                for (const sekki of allSekki) {
                    if (sekki.date > now) {
                        nextSekki = sekki;
                        break;
                    }
                }
                if (nextSekki) {
                    stats.daysToNextSekki = Math.ceil((nextSekki.date - now) / (1000 * 60 * 60 * 24));
                    stats.nextSekkiName = nextSekki.name;
                }
                
                switch(period) {
                    case 'daily':
                        const todayTasks = this.getTodayTasks();
                        stats.normalCompleted = todayTasks.filter(t => t.type === 'normal' && t.isCompleted).length;
                        stats.normalTotal = todayTasks.filter(t => t.type === 'normal').length;
                        stats.goalCompleted = todayTasks.filter(t => t.type === 'urgent' && t.isCompleted).length;
                        stats.goalTotal = todayTasks.filter(t => t.type === 'urgent').length;
                        stats.pointsToday = this.dailyPointHistory[now.toDateString()] || 0;
                        stats.todayReflection = this.dailyReflections[now.toDateString()] || '';
                        break;
                        
                    case 'weekly':
                        stats.normalCompleted = 0;
                        stats.normalTotal = 0;
                        stats.goalCompleted = 0;
                        stats.goalTotal = 0;
                        stats.totalPoints = 0;
                        stats.deadlineCompleted = 0;
                        
                        for (let i = 0; i < 7; i++) {
                            const date = new Date(now);
                            date.setDate(date.getDate() - i);
                            const dateStr = date.toDateString();
                            const dayTasks = this.tasks.filter(t => new Date(t.scheduledFor).toDateString() === dateStr);
                            
                            stats.normalCompleted += dayTasks.filter(t => t.type === 'normal' && t.isCompleted).length;
                            stats.normalTotal += dayTasks.filter(t => t.type === 'normal').length;
                            stats.goalCompleted += dayTasks.filter(t => t.type === 'urgent' && t.isCompleted).length;
                            stats.goalTotal += dayTasks.filter(t => t.type === 'urgent').length;
                            stats.totalPoints += this.dailyPointHistory[dateStr] || 0;
                        }
                        
                        stats.deadlineCompleted = this.deadlineTasks.filter(t => 
                            t.isCompleted && 
                            new Date(t.completedAt) >= new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
                        ).length;
                        break;
                        
                    case 'sekki':
                        // 現在の節気の開始日を取得
                        const currentSekkiData = this.getCurrentSekkiData();
                        if (currentSekkiData) {
                            stats.sekkiStartDate = currentSekkiData.date.toLocaleDateString('ja-JP', { month: 'numeric', day: 'numeric' });
                        }
                        
                    case 'monthly':
                    case 'quarterly':
                        const days = period === 'sekki' ? 15 : period === 'monthly' ? 30 : 90;
                        stats.activeDays = 0;
                        stats.totalPoints = 0;
                        let totalTasks = 0;
                        let completedTasks = 0;
                        let goalTasks = 0;
                        let completedGoals = 0;
                        const reflectionThemes = [];
                        const weeklyReflectionSet = new Set();
                        
                        for (let i = 0; i < days; i++) {
                            const date = new Date(now);
                            date.setDate(date.getDate() - i);
                            const dateStr = date.toDateString();
                            const dayTasks = this.tasks.filter(t => new Date(t.scheduledFor).toDateString() === dateStr);
                            
                            if (dayTasks.length > 0) stats.activeDays++;
                            totalTasks += dayTasks.length;
                            completedTasks += dayTasks.filter(t => t.isCompleted).length;
                            goalTasks += dayTasks.filter(t => t.type === 'urgent').length;
                            completedGoals += dayTasks.filter(t => t.type === 'urgent' && t.isCompleted).length;
                            stats.totalPoints += this.dailyPointHistory[dateStr] || 0;
                            
                            // 振り返りの収集
                            if (this.dailyReflections[dateStr]) {
                                reflectionThemes.push(this.dailyReflections[dateStr]);
                                if (period === 'weekly' && i < 7) {
                                    weeklyReflectionSet.add(this.dailyReflections[dateStr].substring(0, 20) + '...');
                                }
                            }
                        }
                        
                        if (period === 'weekly') {
                            stats.weeklyReflections = Array.from(weeklyReflectionSet).slice(0, 3);
                        }
                        
                        stats.avgCompletionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
                        stats.goalCompletionRate = goalTasks > 0 ? Math.round((completedGoals / goalTasks) * 100) : 0;
                        stats.avgPointsPerDay = stats.activeDays > 0 ? (stats.totalPoints / stats.activeDays).toFixed(1) : 0;
                        
                        // 期間中の節気を収集
                        if (period === 'monthly' || period === 'quarterly') {
                            const sekkiSet = new Set();
                            const startDate = new Date(now);
                            startDate.setDate(startDate.getDate() - days);
                            
                            for (const sekki of allSekki) {
                                if (sekki.date >= startDate && sekki.date <= now) {
                                    sekkiSet.add(sekki.name);
                                }
                            }
                            
                            if (period === 'monthly') {
                                stats.monthSekki = Array.from(sekkiSet);
                            } else {
                                stats.quarterSekki = Array.from(sekkiSet);
                                
                                // 季節の変化を分析
                                const startSeason = getActualSeason(startDate);
                                const endSeason = getActualSeason(now);
                                if (startSeason === endSeason) {
                                    stats.seasonalTransition = `${this.getSeasonName(startSeason)}の期間`;
                                } else {
                                    stats.seasonalTransition = `${this.getSeasonName(startSeason)}から${this.getSeasonName(endSeason)}へ`;
                                }
                            }
                        }
                        
                        if (period === 'quarterly') {
                            // 連続日数計算
                            let currentStreak = 0;
                            stats.maxStreak = 0;
                            
                            for (let i = 0; i < days; i++) {
                                const date = new Date(now);
                                date.setDate(date.getDate() - i);
                                const dayTasks = this.tasks.filter(t => 
                                    new Date(t.scheduledFor).toDateString() === date.toDateString() && 
                                    t.isCompleted
                                );
                                
                                if (dayTasks.length > 0) {
                                    currentStreak++;
                                    stats.maxStreak = Math.max(stats.maxStreak, currentStreak);
                                } else {
                                    currentStreak = 0;
                                }
                            }
                            
                            // 成長傾向分析
                            const firstMonthPoints = this.calculateMonthPoints(2);
                            const lastMonthPoints = this.calculateMonthPoints(0);
                            
                            if (lastMonthPoints > firstMonthPoints * 1.2) {
                                stats.growthTrend = '上昇傾向';
                            } else if (lastMonthPoints < firstMonthPoints * 0.8) {
                                stats.growthTrend = '下降傾向';
                            } else {
                                stats.growthTrend = '安定';
                            }
                        }
                        break;
                }
                
                return stats;
            },
            
            calculateMonthPoints(monthsAgo) {
                const now = new Date();
                const startDate = new Date(now.getFullYear(), now.getMonth() - monthsAgo, 1);
                const endDate = new Date(now.getFullYear(), now.getMonth() - monthsAgo + 1, 0);
                let points = 0;
                
                for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                    points += this.dailyPointHistory[d.toDateString()] || 0;
                }
                
                return points;
            },
            
            getCurrentSekkiData() {
                const now = new Date();
                const year = now.getFullYear();
                const allSekki = [...(sekkiData[year - 1] || []), ...(sekkiData[year] || []), ...(sekkiData[year + 1] || [])];
                let currentSekki = null;
                
                for (const sekki of allSekki) {
                    if (now >= sekki.date) {
                        currentSekki = sekki;
                    } else {
                        break;
                    }
                }
                
                return currentSekki;
            },
            
            getSeasonName(season) {
                return season === 'spring' ? '春' : season === 'summer' ? '夏' : season === 'autumn' ? '秋' : '冬';
            },
            
            render() {
                const selectedDateTasks = this.getTodayTasks(); 
                const completedCount = selectedDateTasks.filter(t => t.isCompleted).length;
                const isToday = this.selectedDate.toDateString() === new Date().toDateString();

                document.getElementById('currentDate').textContent = this.formatDate(this.selectedDate);
                document.getElementById('todayButton').classList.toggle('hidden', isToday);
                document.getElementById('completedCount').textContent = completedCount;
                document.getElementById('totalCount').textContent = selectedDateTasks.length;
                document.getElementById('totalPointsDisplay').textContent = this.totalPoints;
                document.getElementById('totalPointsStats').textContent = this.totalPoints;

                const activeNormalCount = selectedDateTasks.filter(t => t.type === 'normal' && !t.isCompleted).length;
                const activeUrgentCount = selectedDateTasks.filter(t => t.type === 'urgent' && !t.isCompleted).length;
                document.getElementById('normalSlots').textContent = Math.max(0, 3 - activeNormalCount);
                document.getElementById('urgentSlots').textContent = Math.max(0, 3 - activeUrgentCount);
                document.getElementById('normalType').disabled = (3 - activeNormalCount) <= 0;
                document.getElementById('urgentType').disabled = (3 - activeUrgentCount) <= 0;

                const taskList = document.getElementById('taskList');
                taskList.innerHTML = ''; 
                
                selectedDateTasks.sort((a,b) => new Date(a.createdAt) - new Date(b.createdAt)).forEach((task, index) => { 
                    const taskEl = document.createElement('div');
                    let taskSpecificClass = '';
                    if (task.isCompleted) { taskSpecificClass = 'task-completed'; } 
                    else if (task.type === 'urgent') { taskSpecificClass = 'task-urgent-active'; } 
                    else { taskSpecificClass = 'task-normal-active'; }
                    taskEl.className = `washi-card task-card rounded-xl p-4 mobile-compact transition-all animate-fadeInUp ${taskSpecificClass}`;
                    taskEl.style.animationDelay = `${index * 0.05}s`; 
                    
                    taskEl.innerHTML = `
                        <div class="flex items-center gap-3">
                            <button data-task-id="${task.id}" class="task-toggle-button flex-shrink-0 wa-checkbox ${task.isCompleted ? 'checked' : ''} flex items-center justify-center rounded-md"></button>
                            <div class="flex-1 min-w-0">
                                <p class="task-text-lg break-words">${task.text}</p> <!-- Removed specific color classes here, handled by parent -->
                                <div class="flex items-center gap-3 mt-1">
                                    <span class="task-type-label"> <!-- Styling now comes from parent context -->
                                        ${task.type === 'urgent' ? `【目標】${task.points ? ` ${task.points}pt` : ''}` : '【通常】'}
                                    </span>
                                    ${task.completedAt ? `<span class="task-completed-badge"><svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>完了!</span>` : ''}
                                </div>
                            </div>
                            <div class="flex items-center gap-1">
                                ${!task.isCompleted ? `
                                    <button data-task-id="${task.id}" class="task-postpone-button p-2.5 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-full transition-all min-w-[44px] min-h-[44px] flex items-center justify-center" title="明日へ">
                                        <svg class="w-5 h-5 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>
                                    </button>
                                ` : ''}
                                <button data-task-id="${task.id}" class="task-delete-button p-2.5 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded-full transition-all text-xl leading-none min-w-[44px] min-h-[44px] flex items-center justify-center" title="削除">×</button>
                            </div>
                        </div>
                    `;
                    taskList.appendChild(taskEl);
                });

                document.getElementById('noTasks').classList.toggle('hidden', selectedDateTasks.length > 0);

                const deadlineList = document.getElementById('deadlineList');
                deadlineList.innerHTML = '';
                this.deadlineTasks
                    .sort((a,b) => { /* Sort logic unchanged */
                        if (a.isCompleted && !b.isCompleted) return 1;
                        if (!a.isCompleted && b.isCompleted) return -1;
                        const daysA = this.getDaysUntilDeadline(a.deadline);
                        const daysB = this.getDaysUntilDeadline(b.deadline);
                        if (daysA !== daysB) return daysA - daysB;
                        return new Date(a.createdAt) - new Date(b.createdAt);
                    })
                    .forEach(task => {
                    const daysLeft = this.getDaysUntilDeadline(task.deadline);
                    const isUrgent = daysLeft <= 3 && daysLeft >=0 && !task.isCompleted; 
                    const isOverdue = daysLeft < 0 && !task.isCompleted;
                    const taskEl = document.createElement('div');
                    taskEl.className = `p-3 rounded-lg border transition-all ${ task.isCompleted ? 'border-gray-300 bg-gray-50 opacity-60' : isOverdue ? 'border-red-400 bg-red-50' : isUrgent ? 'border-orange-400 bg-orange-50' : 'border-gray-300 bg-gray-50' }`;
                    taskEl.innerHTML = `
                        <div class="flex items-center justify-between">
                            <div class="flex-1 min-w-0">
                                <p class="text-sm sm:text-base font-medium break-words ${task.isCompleted ? 'text-green-700' : 'text-gray-800'}">${task.text}</p>
                                <p class="text-xs sm:text-sm mt-1 ${ task.isCompleted ? 'text-gray-500' : isOverdue ? 'text-red-700 font-medium' : isUrgent ? 'text-orange-700 font-medium' : 'text-gray-600' }">
                                    ${task.isCompleted ? `✓ 完了済み (${new Date(task.completedAt).toLocaleDateString('ja-JP', {month:'numeric', day:'numeric'})})` : isOverdue ? `${Math.abs(daysLeft)}日超過` : daysLeft === 0 ? '本日まで' : `あと${daysLeft}日`}
                                    ・期限: ${new Date(task.deadline).toLocaleDateString('ja-JP', { month: 'numeric', day: 'numeric' })}
                                </p>
                            </div>
                            <!-- Action buttons for deadline tasks -->
                            <div class="flex items-center gap-1 ml-2">
                                <button data-task-id="${task.id}" class="deadline-task-toggle-button flex-shrink-0 wa-checkbox ${task.isCompleted ? 'checked' : ''} flex items-center justify-center rounded-md" style="min-width: 36px; min-height: 36px; width: 36px; height: 36px;"></button>
                                <!-- NEW: Delete button for deadline task -->
                                <button data-task-id="${task.id}" class="deadline-task-delete-button p-2 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded-full transition-all text-lg leading-none" title="削除">×</button>
                            </div>
                        </div>
                    `;
                    deadlineList.appendChild(taskEl);
                });

                const activeDeadlines = this.deadlineTasks.filter(t => !t.isCompleted).length;
                document.getElementById('noDeadlineTasks').classList.toggle('hidden', this.deadlineTasks.length > 0);
                const deadlineToggleButton = document.getElementById('deadlineToggle');
                deadlineToggleButton.disabled = activeDeadlines >= 3;
                deadlineToggleButton.querySelector('svg').style.opacity = activeDeadlines >= 3 ? '0.3' : '1';

                const inboxList = document.getElementById('inboxList');
                inboxList.innerHTML = '';
                this.inboxItems.forEach(item => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'flex items-center justify-between p-3 bg-gray-50 rounded-lg text-gray-700 border border-gray-200 text-sm';
                    itemEl.innerHTML = `
                        <span class="break-all">${item.text}</span>
                        <button data-item-id="${item.id}" class="inbox-item-delete-button ml-2 p-1 text-gray-400 hover:text-red-500 text-lg leading-none">×</button>
                    `;
                    inboxList.appendChild(itemEl);
                });
                
                // 振り返り表示
                const dateStr = this.selectedDate.toDateString();
                const reflection = this.dailyReflections[dateStr];
                const reflectionDisplay = document.getElementById('reflectionDisplay');
                const noReflection = document.getElementById('noReflection');
                
                if (reflection) {
                    reflectionDisplay.textContent = reflection;
                    reflectionDisplay.classList.remove('hidden');
                    noReflection.classList.add('hidden');
                } else {
                    reflectionDisplay.classList.add('hidden');
                    noReflection.classList.remove('hidden');
                }
                
                // AIコメント表示
                const aiCommentDisplay = document.getElementById('aiCommentDisplay');
                const noApiKey = document.getElementById('noApiKey');
                const aiCommentContent = document.getElementById('aiCommentContent');
                const aiCommentLoading = document.getElementById('aiCommentLoading');
                
                if (this.openaiApiKey) {
                    noApiKey.classList.add('hidden');
                    if (!aiCommentContent.textContent && !aiCommentLoading.classList.contains('hidden')) {
                        aiCommentContent.classList.add('hidden');
                    }
                } else {
                    noApiKey.classList.remove('hidden');
                    aiCommentContent.classList.add('hidden');
                    aiCommentLoading.classList.add('hidden');
                }
                
                this.bindDynamicEvents();
            },

            bindDynamicEvents() {
                document.querySelectorAll('.task-toggle-button').forEach(button => { button.addEventListener('click', (e) => this.toggleTask(e.currentTarget.dataset.taskId)); });
                document.querySelectorAll('.task-postpone-button').forEach(button => { button.addEventListener('click', (e) => this.postponeTask(e.currentTarget.dataset.taskId)); });
                document.querySelectorAll('.task-delete-button').forEach(button => { button.addEventListener('click', (e) => this.deleteTask(e.currentTarget.dataset.taskId)); });
                
                document.querySelectorAll('.deadline-task-toggle-button').forEach(button => { button.addEventListener('click', (e) => this.toggleDeadlineTask(e.currentTarget.dataset.taskId)); });
                // --- NEW: Bind delete for deadline tasks ---
                document.querySelectorAll('.deadline-task-delete-button').forEach(button => {
                    button.addEventListener('click', (e) => this.deleteDeadlineTask(e.currentTarget.dataset.taskId));
                });

                document.querySelectorAll('.inbox-item-delete-button').forEach(button => { button.addEventListener('click', (e) => this.deleteInboxItem(e.currentTarget.dataset.itemId)); });
                document.querySelectorAll('button:not([data-ripple-bound])').forEach(button => {
                    button.style.position = 'relative'; 
                    button.style.overflow = 'hidden';  
                    button.addEventListener('click', createRipple);
                    button.setAttribute('data-ripple-bound', 'true'); 
                });
            }
        };
        app.init();
    </script>
</body>
</html>
